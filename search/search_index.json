{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tri par s\u00e9lection et par insertion Bienvenue, ce site est d\u00e9di\u00e9 au cours de premi\u00e8re NSI sur le tri par s\u00e9lection et par insertion . COURS : Cours tri par s\u00e9lection Cours tri par insertion \u00c9VALUATIONS : Interro tri par s\u00e9lection Correction interro tri par s\u00e9lection Demerville Erwan Me contacter : demerville.erwan@gmail.com","title":"Tri par s\u00e9lection et par insertion"},{"location":"#tri-par-selection-et-par-insertion","text":"Bienvenue, ce site est d\u00e9di\u00e9 au cours de premi\u00e8re NSI sur le tri par s\u00e9lection et par insertion . COURS : Cours tri par s\u00e9lection Cours tri par insertion \u00c9VALUATIONS : Interro tri par s\u00e9lection Correction interro tri par s\u00e9lection Demerville Erwan Me contacter : demerville.erwan@gmail.com","title":"Tri par s\u00e9lection et par insertion"},{"location":"activite_preliminaire/","text":"Activit\u00e9 pr\u00e9liminaire sur les tris L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus. On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Partie 1 : Exp\u00e9rimentation La zone de jeu est constitu\u00e9e : d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7 , d'une zone temporaire dans laquelle on peut stocker l' indice ou la valeur d'une carte. Zone de jeu \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : Disposer une suite de 8 cartes arbitrairement choisies sur votre table. \u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes . Vous l'\u00e9crirez sur un bloc-note https://collab.infoforall.fr/ . Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'elle fonctionne toujours. Important Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes : comparer les valeurs de deux cartes , permuter (\u00e9changer) deux cartes , copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement), vous pouvez utiliser des conditions ( SI ... , SINON ) et des boucles ( TANT QUE , POUR ... ALLANT DE ... A ... ). Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter : vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re), si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal), votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel. Partie 2 : Bilan des strat\u00e9gies Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes . \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement . Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas. Partie 3 : Tri par s\u00e9lection Principe du tri par s\u00e9lection Le tri par s\u00e9lection se d\u00e9roule comme suit : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la liste. Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite ) ayant cette valeur. \u00c0 faire 1 D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement. On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine , c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite. Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine , la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations , des comparaisons et des conditions . Recherche de la plus faible carte Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 : Stocker l' indice \\(i\\) dans la zone temporaire . En parcourant la suite de cartes de gauche \u00e0 droite , \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite : Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire . SI une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire , remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l' indice de cette carte . Renvoyer enfin l' indice contenu dans la zone temporaire . \u00c0 faire 2 Vous devez \u00e0 pr\u00e9sent : D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection , en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies. Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es. Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?","title":"Activit\u00e9 pr\u00e9liminaire sur les tris"},{"location":"activite_preliminaire/#activite-preliminaire-sur-les-tris","text":"L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus. On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.","title":"Activit\u00e9 pr\u00e9liminaire sur les tris"},{"location":"activite_preliminaire/#partie-1-experimentation","text":"La zone de jeu est constitu\u00e9e : d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7 , d'une zone temporaire dans laquelle on peut stocker l' indice ou la valeur d'une carte. Zone de jeu \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : Disposer une suite de 8 cartes arbitrairement choisies sur votre table. \u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes . Vous l'\u00e9crirez sur un bloc-note https://collab.infoforall.fr/ . Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'elle fonctionne toujours. Important Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes : comparer les valeurs de deux cartes , permuter (\u00e9changer) deux cartes , copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement), vous pouvez utiliser des conditions ( SI ... , SINON ) et des boucles ( TANT QUE , POUR ... ALLANT DE ... A ... ). Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter : vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re), si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal), votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel.","title":"Partie 1 : Exp\u00e9rimentation"},{"location":"activite_preliminaire/#partie-2-bilan-des-strategies","text":"Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes . \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement . Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas.","title":"Partie 2 : Bilan des strat\u00e9gies"},{"location":"activite_preliminaire/#partie-3-tri-par-selection","text":"Principe du tri par s\u00e9lection Le tri par s\u00e9lection se d\u00e9roule comme suit : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la liste. Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite ) ayant cette valeur. \u00c0 faire 1 D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement. On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine , c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite. Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine , la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations , des comparaisons et des conditions . Recherche de la plus faible carte Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 : Stocker l' indice \\(i\\) dans la zone temporaire . En parcourant la suite de cartes de gauche \u00e0 droite , \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite : Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire . SI une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire , remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l' indice de cette carte . Renvoyer enfin l' indice contenu dans la zone temporaire . \u00c0 faire 2 Vous devez \u00e0 pr\u00e9sent : D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection , en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies. Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es. Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?","title":"Partie 3 : Tri par s\u00e9lection"},{"location":"de_cote/","text":"L'algorithme (tri insertion) Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Fonction tri_par_insertion(Tableau T) Pour i de 1 \u00e0 taille(T) - 1 valeur_courante = T[i] position = i # D\u00e9terminer la position de l'\u00e9l\u00e9ment \u00e0 placer (valeur_courante) Tant que position > 0 et T[position - 1] > valeur_courante T[position] = T[position - 1] position = position - 1 T[position] = valeur_courante # Placer l'\u00e9l\u00e9ment au bon endroit Fin Pour Fin Fonction Ce que fait cet algorithme, c'est qu'il it\u00e8re sur chaque \u00e9l\u00e9ment du tableau. Pour chaque \u00e9l\u00e9ment, il trouve sa position correcte parmi les \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s \u00e0 sa gauche en d\u00e9pla\u00e7ant tous les \u00e9l\u00e9ments vers la droite jusqu'\u00e0 ce qu'il trouve la bonne position, puis il ins\u00e8re l'\u00e9l\u00e9ment \u00e0 cette position. Cela continue jusqu'\u00e0 ce que tout le tableau soit tri\u00e9. i est l'indice (fl\u00e8che en vert clair dans l'animation) de la cl\u00e9-valeur qu'il faut placer POUR i variant de 1 \u00e0 (longueur - 1) inclus cle \u2190 t[i] on m\u00e9morise dans cle la valeur-cl\u00e9 car cette case risque d'\u00eatre \u00e9cras\u00e9e j \u2190 i - 1 La variable j contient initialement l'indice juste \u00e0 gauche de la cl\u00e9 (fl\u00e8che verte dans l'animation) TANT QUE j \u2265 0 et que t[j] > cle t[j+1] \u2190 t[j] On d\u00e9cale la valeur d'une case \u00e0 droite j \u2190 j - 1 On passe \u00e0 la case suivante \u00e0 gauche Fin TANT QUE t[j+1] \u2190 cle On place la valeur-cl\u00e9 \u00e0 la place voulue pour obtenir un sous-tableau tri\u00e9 Fin POUR Renvoyer VIDE (\u2205)","title":"De cote"},{"location":"de_cote/#lalgorithme-tri-insertion","text":"Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Fonction tri_par_insertion(Tableau T) Pour i de 1 \u00e0 taille(T) - 1 valeur_courante = T[i] position = i # D\u00e9terminer la position de l'\u00e9l\u00e9ment \u00e0 placer (valeur_courante) Tant que position > 0 et T[position - 1] > valeur_courante T[position] = T[position - 1] position = position - 1 T[position] = valeur_courante # Placer l'\u00e9l\u00e9ment au bon endroit Fin Pour Fin Fonction Ce que fait cet algorithme, c'est qu'il it\u00e8re sur chaque \u00e9l\u00e9ment du tableau. Pour chaque \u00e9l\u00e9ment, il trouve sa position correcte parmi les \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s \u00e0 sa gauche en d\u00e9pla\u00e7ant tous les \u00e9l\u00e9ments vers la droite jusqu'\u00e0 ce qu'il trouve la bonne position, puis il ins\u00e8re l'\u00e9l\u00e9ment \u00e0 cette position. Cela continue jusqu'\u00e0 ce que tout le tableau soit tri\u00e9. i est l'indice (fl\u00e8che en vert clair dans l'animation) de la cl\u00e9-valeur qu'il faut placer POUR i variant de 1 \u00e0 (longueur - 1) inclus cle \u2190 t[i] on m\u00e9morise dans cle la valeur-cl\u00e9 car cette case risque d'\u00eatre \u00e9cras\u00e9e j \u2190 i - 1 La variable j contient initialement l'indice juste \u00e0 gauche de la cl\u00e9 (fl\u00e8che verte dans l'animation) TANT QUE j \u2265 0 et que t[j] > cle t[j+1] \u2190 t[j] On d\u00e9cale la valeur d'une case \u00e0 droite j \u2190 j - 1 On passe \u00e0 la case suivante \u00e0 gauche Fin TANT QUE t[j+1] \u2190 cle On place la valeur-cl\u00e9 \u00e0 la place voulue pour obtenir un sous-tableau tri\u00e9 Fin POUR Renvoyer VIDE (\u2205)","title":"L'algorithme (tri insertion)"},{"location":"tri_insertion/","text":"Le tri par insertion Nous avons vu la m\u00e9thode de tri par s\u00e9lection , qui a l'avantage d'\u00eatre facile \u00e0 appr\u00e9hender, mais qui s'av\u00e8re \u00eatre fortement co\u00fbteuse (co\u00fbt quadratique dans tous les cas ). Voyons s'il n'existe pas d'autres algorithmes de tri plus int\u00e9ressants. Pr\u00e9sentation du tri par insertion Avec un jeu de cartes Le tri par insertion est un autre algorithme de tri par comparaisons , dont le principe est un peu diff\u00e9rent, mais plus \"naturel\". Dans cette partie, on verra comment trier une suite de cartes en utilisant la m\u00e9thode de tri par insertion . On utilisera l' ordre suivant (de la carte la plus faible \u00e0 la plus forte ) : Note : Si vous avez une carte Joker dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Activit\u00e9 pr\u00e9liminaire Munissez-vous d'un paquet de carte, m\u00e9langez-le , et placez-le en face cach\u00e9e . Vous disposez d'une zone de jeu dans laquelle vous ajouterez les cartes une par une , de mani\u00e8re \u00e0 toujours avoir une suite de cartes tri\u00e9e . L'objectif est de trier les 7 premi\u00e8res cartes du paquet. Prenez la premi\u00e8re carte du paquet et posez-la (face visible) dans votre zone de jeu. La suite de cartes de votre zone de jeu (compos\u00e9e pour le moment d'une seule carte) est-elle tri\u00e9e ? Prenez la deuxi\u00e8me carte du paquet, et int\u00e9grez-la \u00e0 votre suite de cartes de mani\u00e8re \u00e0 ce que celle-ci reste tri\u00e9e . Prenez la troisi\u00e8me carte du paquet et faites de m\u00eame. R\u00e9p\u00e9tez cela jusqu'\u00e0 avoir une suite de 7 cartes tri\u00e9es dans votre zone de jeu. Question : D\u00e9crivez la m\u00e9thode que vous avez suivi pour int\u00e9grer chaque nouvelle carte \u00e0 votre suite de cartes tri\u00e9e. Voici le d\u00e9roulement de la m\u00e9thode de tri par insertion sur une suite de cartes . On souhaite trier la suite de cartes suivantes : Une suite de 5 cartes. Composition du tableau On distingue deux parties dans le tableau : une partie tri\u00e9e (en vert ), initialement compos\u00e9e de la premi\u00e8re carte . une partie non-tri\u00e9e (en gris ), initialement compos\u00e9e du reste des cartes . On dispose \u00e9galement d'une zone m\u00e9moire dans laquelle peut placer une carte temporairement . On commence donc par traiter la deuxi\u00e8me carte du tableau , qui est la premi\u00e8re carte de la partie non-tri\u00e9e . On place cette carte dans la zone m\u00e9moire . Ensuite, on proc\u00e8de comme suit : Placer la carte \u00e0 sa bonne position En partant de la carte positionn\u00e9e juste \u00e0 gauche de celle que l'on cherche \u00e0 trier (c'est-\u00e0-dire la derni\u00e8re carte de la partie tri\u00e9e du tableau), et en allant jusqu'\u00e0 la premi\u00e8re carte du tableau : On d\u00e9cale d'une position \u00e0 droite chaque carte dont la valeur est strictement sup\u00e9rieure \u00e0 la carte que l'on cherche \u00e0 replacer. On s'arr\u00eate uniquement si la carte n'a pas une valeur sup\u00e9rieure , ou si l'on a parcouru toutes les cartes . On replace la carte (actuellement en m\u00e9moire ) \u00e0 sa bonne position . Ici, la carte qui pr\u00e9c\u00e8de celle \u00e0 replacer (qui se trouve en m\u00e9moire) est inf\u00e9rieure \u00e0 la carte \u00e0 replacer. Cela signifie que notre carte est d\u00e9j\u00e0 \u00e0 sa bonne position . Il n'y a donc pas de d\u00e9calage \u00e0 faire , et on replace la carte \u00e0 sa position initiale . La partie tri\u00e9e de notre tableau est maintenant compos\u00e9e des deux premi\u00e8res cartes . On fait de m\u00eame avec la troisi\u00e8me carte du tableau (premi\u00e8re carte de la partie non-tri\u00e9e ). Ici encore, la carte \u00e9tait d\u00e9j\u00e0 \u00e0 sa bonne position. On a maintenant 3 cartes dans la partie tri\u00e9e du tableau. On met la quatri\u00e8me carte (de valeur 3 ) en m\u00e9moire . On constate que les deux cartes pr\u00e9c\u00e9dentes (de valeurs 8 et 4 ) ont une valeur sup\u00e9rieure \u00e0 celle de la carte que l'on souhaite trier. Il faut donc d\u00e9placer \u00e0 droite ces deux cartes. On peut maintenant repositionner notre carte. Il ne reste ainsi plus qu'une seule carte dans la partie non-tri\u00e9e de notre tableau. On r\u00e9p\u00e8te le m\u00eame principe, on place cette carte en m\u00e9moire . Ici, il n'y a que la carte pr\u00e9c\u00e9dente \u00e0 d\u00e9placer. Puis on repositionne notre carte. Et voil\u00e0, on vient de trier une suite de 5 cartes par la m\u00e9thode de tri par insertion ! \u00c0 vous de jouer Disposez une suite de 7 cartes choisies au hasard dans un paquet de cartes. Votre zone de jeu est compos\u00e9e de votre suite de cartes et d'un emplacement m\u00e9moire . Effectuez le tri de votre suite de cartes en utilisant la m\u00e9thode de tri par insertion pr\u00e9sent\u00e9e ci-dessus. Trier un tableau On a donc vu que la m\u00e9thode de tri par insertion avait l'avantage d'\u00eatre assez naturelle , raison pour laquelle elle est souvent utilis\u00e9e pour trier des cartes \u00e0 jouer . Appliquons \u00e0 pr\u00e9sent ce tri sur des tableaux d'entiers . On rappelle le principe du tri par insertion : on fait comme si les \u00e9l\u00e9ments de la partie non-tri\u00e9e du tableau \u00e9taient donn\u00e9s un par un , le premier \u00e9l\u00e9ment du tableau constituant, \u00e0 lui seul , un tableau tri\u00e9e de longueur 1 , on y range ensuite le deuxi\u00e8me \u00e9l\u00e9ment du tableau pour constituer un tableau tri\u00e9 de longueur 2 , puis on y range le troisi\u00e8me \u00e9l\u00e9ment pour obtenir un tableau tri\u00e9 longueur 3 , et ainsi de suite jusqu\u2019\u00e0 avoir trait\u00e9 le dernier \u00e9l\u00e9ment... On ins\u00e8re donc \u00e0 la n i\u00e8me it\u00e9ration le n i\u00e8me \u00e9l\u00e9ment \u00e0 sa bonne position en d\u00e9calant \u00e0 droite tous les \u00e9l\u00e9ments de la partie tri\u00e9e du tableau qui lui sont sup\u00e9rieurs. Exercice - Trier un tableau On souhaite trier le tableau suivant avec le tri par insertion : [5, 3, 1, 4, 6, 2] . Indiquez quel est l' \u00e9tat du tableau apr\u00e8s chaque insertion d'\u00e9l\u00e9ment . Source : http://fractale.gecif.net/nsi/pdf/cours/algorithmes/algo_tri.pdf Faites de m\u00eame avec le tableau [2,8,1,5,2,3] . L'algorithme Pr\u00e9sentation de l'algorithme Note Dans la partie pr\u00e9c\u00e9dente, on a souvent parl\u00e9 de \"d\u00e9placements\" de cartes. En machine, ces d\u00e9placements seront impl\u00e9ment\u00e9s sous la forme de copies d'\u00e9l\u00e9ments , en r\u00e9alisant des affectations. Algorithme du tri par insertion ALGORITHME : tri_insertion ENTR\u00c9E : \u2003\u2003 tableau : un tableau d'\u00e9l\u00e9ments SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003 POUR i ALLANT DE 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003\u2003valeur_courante \u2190 tableau[i] \u2003\u2003\u2003\u2003j \u2190 i \\(-\\) 1 \u2003\u2003\u2003\u2003 TANT QUE j \u2265 0 ET QUE tableau[j] > valeur_courante \u2003\u2003\u2003\u2003\u2003\u2003tableau[j + 1] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003j \u2190 j \\(-\\) 1 \u2003\u2003\u2003\u2003 FIN TANT QUE \u2003\u2003\u2003\u2003tableau[j + 1] \u2190 valeur_courante \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Exercice 1 D\u00e9roulez l'algorithme sur le tableau [5, 3, 1, 4, 6, 2] . Exercice 2 Pourquoi commence t-on la boucle POUR \u00e0 partir de 1 ? Expliquez \u00e0 quoi sert la 3 \u00e8me ligne de l' algorithme : j \u2190 i - 1 . Dans le TANT QUE , \u00e0 quoi sert la premi\u00e8re condition j \u2265 0 ? La deuxi\u00e8me condition tableau[j] > valeur_courante ? Pourrait t-on inverser les deux conditions ? \u00c0 quoi sert la ligne tableau[j + 1] \u2190 tableau[j] dans le TANT QUE ? Pourquoi d\u00e9cr\u00e9mente t-on (c'est-\u00e0-dire que l'on diminue de 1) la valeur de j \u00e0 chaque tour de la boucle TANT QUE ? Expliquez l' affectation tableau[j + 1] \u2190 valeur_courante apr\u00e8s la boucle TANT QUE . Tri stable Le tri par insertion , \u00e9crit comme ci-dessus, est dit \" stable \" car, en cas de valeurs identiques dans le tableau initial, leur ordre relatif n\u2019est pas modifi\u00e9 . Une petite animation Simulation du tri par insertion En vert : \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s En gris : \u00e9l\u00e9ments \u00e0 trier Espace m\u00e9moire: Lancer le tri Pas \u00e0 pas Impl\u00e9mentation en Python Maintenant que l'on a d\u00e9termin\u00e9 l' algorithme du tri par insertion , on peut l' impl\u00e9menter en Python . T\u00e9l\u00e9chargez le programme squelette (\u00e0 compl\u00e9ter) ci-dessous. Fichiers Python tri_insertion.py : programme Python avec les fonctions \u00e0 compl\u00e9ter. (\u00e0 venir) : programme Python corrig\u00e9. Module doctest Dans la docstring de la fonction tri_insertion , des tests sont pr\u00e9sents. Ces tests sont ex\u00e9cut\u00e9s par le module natif doctest . Lorsque vous ex\u00e9cutez le programme, si les tests r\u00e9ussissent, rien ne se passera . Sinon, vous obtiendrez des informations sur les tests qui ont \u00e9chou\u00e9. La fonction testmod (qui ex\u00e9cute les tests ) est appel\u00e9e dans la derni\u00e8re ligne du programme. Pour obtenir davantage d'informations sur les erreurs li\u00e9es aux tests, vous pouvez activer le mode verbeux en rempla\u00e7ant le param\u00e8tre verbose=False par verbose=True . Exercice pr\u00e9liminaire Dans les tests pr\u00e9sents dans la docstring de la fonction tri_insertion , la premi\u00e8re instruction est la suivante : >>> l = [randint(0, 99) for _ in range(10)] Expliquez ce que fait cette instruction. Exercice 1 \u00c9crivez la fonction tri_insertion . Ex\u00e9cutez le programme pour vous assurer que votre fonction soit correcte (il ne doit rien se passer). Exercice 2 \u00c9crivez la fonction tri_insertion_decroissant permettant de trier un tableau dans l'ordre d\u00e9croissant . Que faut-il changer par rapport \u00e0 la fonction tri_insertion ?","title":"Tri par insertion"},{"location":"tri_insertion/#le-tri-par-insertion","text":"Nous avons vu la m\u00e9thode de tri par s\u00e9lection , qui a l'avantage d'\u00eatre facile \u00e0 appr\u00e9hender, mais qui s'av\u00e8re \u00eatre fortement co\u00fbteuse (co\u00fbt quadratique dans tous les cas ). Voyons s'il n'existe pas d'autres algorithmes de tri plus int\u00e9ressants.","title":"Le tri par insertion"},{"location":"tri_insertion/#presentation-du-tri-par-insertion","text":"","title":"Pr\u00e9sentation du tri par insertion"},{"location":"tri_insertion/#avec-un-jeu-de-cartes","text":"Le tri par insertion est un autre algorithme de tri par comparaisons , dont le principe est un peu diff\u00e9rent, mais plus \"naturel\". Dans cette partie, on verra comment trier une suite de cartes en utilisant la m\u00e9thode de tri par insertion . On utilisera l' ordre suivant (de la carte la plus faible \u00e0 la plus forte ) : Note : Si vous avez une carte Joker dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Activit\u00e9 pr\u00e9liminaire Munissez-vous d'un paquet de carte, m\u00e9langez-le , et placez-le en face cach\u00e9e . Vous disposez d'une zone de jeu dans laquelle vous ajouterez les cartes une par une , de mani\u00e8re \u00e0 toujours avoir une suite de cartes tri\u00e9e . L'objectif est de trier les 7 premi\u00e8res cartes du paquet. Prenez la premi\u00e8re carte du paquet et posez-la (face visible) dans votre zone de jeu. La suite de cartes de votre zone de jeu (compos\u00e9e pour le moment d'une seule carte) est-elle tri\u00e9e ? Prenez la deuxi\u00e8me carte du paquet, et int\u00e9grez-la \u00e0 votre suite de cartes de mani\u00e8re \u00e0 ce que celle-ci reste tri\u00e9e . Prenez la troisi\u00e8me carte du paquet et faites de m\u00eame. R\u00e9p\u00e9tez cela jusqu'\u00e0 avoir une suite de 7 cartes tri\u00e9es dans votre zone de jeu. Question : D\u00e9crivez la m\u00e9thode que vous avez suivi pour int\u00e9grer chaque nouvelle carte \u00e0 votre suite de cartes tri\u00e9e. Voici le d\u00e9roulement de la m\u00e9thode de tri par insertion sur une suite de cartes . On souhaite trier la suite de cartes suivantes : Une suite de 5 cartes. Composition du tableau On distingue deux parties dans le tableau : une partie tri\u00e9e (en vert ), initialement compos\u00e9e de la premi\u00e8re carte . une partie non-tri\u00e9e (en gris ), initialement compos\u00e9e du reste des cartes . On dispose \u00e9galement d'une zone m\u00e9moire dans laquelle peut placer une carte temporairement . On commence donc par traiter la deuxi\u00e8me carte du tableau , qui est la premi\u00e8re carte de la partie non-tri\u00e9e . On place cette carte dans la zone m\u00e9moire . Ensuite, on proc\u00e8de comme suit : Placer la carte \u00e0 sa bonne position En partant de la carte positionn\u00e9e juste \u00e0 gauche de celle que l'on cherche \u00e0 trier (c'est-\u00e0-dire la derni\u00e8re carte de la partie tri\u00e9e du tableau), et en allant jusqu'\u00e0 la premi\u00e8re carte du tableau : On d\u00e9cale d'une position \u00e0 droite chaque carte dont la valeur est strictement sup\u00e9rieure \u00e0 la carte que l'on cherche \u00e0 replacer. On s'arr\u00eate uniquement si la carte n'a pas une valeur sup\u00e9rieure , ou si l'on a parcouru toutes les cartes . On replace la carte (actuellement en m\u00e9moire ) \u00e0 sa bonne position . Ici, la carte qui pr\u00e9c\u00e8de celle \u00e0 replacer (qui se trouve en m\u00e9moire) est inf\u00e9rieure \u00e0 la carte \u00e0 replacer. Cela signifie que notre carte est d\u00e9j\u00e0 \u00e0 sa bonne position . Il n'y a donc pas de d\u00e9calage \u00e0 faire , et on replace la carte \u00e0 sa position initiale . La partie tri\u00e9e de notre tableau est maintenant compos\u00e9e des deux premi\u00e8res cartes . On fait de m\u00eame avec la troisi\u00e8me carte du tableau (premi\u00e8re carte de la partie non-tri\u00e9e ). Ici encore, la carte \u00e9tait d\u00e9j\u00e0 \u00e0 sa bonne position. On a maintenant 3 cartes dans la partie tri\u00e9e du tableau. On met la quatri\u00e8me carte (de valeur 3 ) en m\u00e9moire . On constate que les deux cartes pr\u00e9c\u00e9dentes (de valeurs 8 et 4 ) ont une valeur sup\u00e9rieure \u00e0 celle de la carte que l'on souhaite trier. Il faut donc d\u00e9placer \u00e0 droite ces deux cartes. On peut maintenant repositionner notre carte. Il ne reste ainsi plus qu'une seule carte dans la partie non-tri\u00e9e de notre tableau. On r\u00e9p\u00e8te le m\u00eame principe, on place cette carte en m\u00e9moire . Ici, il n'y a que la carte pr\u00e9c\u00e9dente \u00e0 d\u00e9placer. Puis on repositionne notre carte. Et voil\u00e0, on vient de trier une suite de 5 cartes par la m\u00e9thode de tri par insertion ! \u00c0 vous de jouer Disposez une suite de 7 cartes choisies au hasard dans un paquet de cartes. Votre zone de jeu est compos\u00e9e de votre suite de cartes et d'un emplacement m\u00e9moire . Effectuez le tri de votre suite de cartes en utilisant la m\u00e9thode de tri par insertion pr\u00e9sent\u00e9e ci-dessus.","title":"Avec un jeu de cartes"},{"location":"tri_insertion/#trier-un-tableau","text":"On a donc vu que la m\u00e9thode de tri par insertion avait l'avantage d'\u00eatre assez naturelle , raison pour laquelle elle est souvent utilis\u00e9e pour trier des cartes \u00e0 jouer . Appliquons \u00e0 pr\u00e9sent ce tri sur des tableaux d'entiers . On rappelle le principe du tri par insertion : on fait comme si les \u00e9l\u00e9ments de la partie non-tri\u00e9e du tableau \u00e9taient donn\u00e9s un par un , le premier \u00e9l\u00e9ment du tableau constituant, \u00e0 lui seul , un tableau tri\u00e9e de longueur 1 , on y range ensuite le deuxi\u00e8me \u00e9l\u00e9ment du tableau pour constituer un tableau tri\u00e9 de longueur 2 , puis on y range le troisi\u00e8me \u00e9l\u00e9ment pour obtenir un tableau tri\u00e9 longueur 3 , et ainsi de suite jusqu\u2019\u00e0 avoir trait\u00e9 le dernier \u00e9l\u00e9ment... On ins\u00e8re donc \u00e0 la n i\u00e8me it\u00e9ration le n i\u00e8me \u00e9l\u00e9ment \u00e0 sa bonne position en d\u00e9calant \u00e0 droite tous les \u00e9l\u00e9ments de la partie tri\u00e9e du tableau qui lui sont sup\u00e9rieurs. Exercice - Trier un tableau On souhaite trier le tableau suivant avec le tri par insertion : [5, 3, 1, 4, 6, 2] . Indiquez quel est l' \u00e9tat du tableau apr\u00e8s chaque insertion d'\u00e9l\u00e9ment . Source : http://fractale.gecif.net/nsi/pdf/cours/algorithmes/algo_tri.pdf Faites de m\u00eame avec le tableau [2,8,1,5,2,3] .","title":"Trier un tableau"},{"location":"tri_insertion/#lalgorithme","text":"","title":"L'algorithme"},{"location":"tri_insertion/#presentation-de-lalgorithme","text":"Note Dans la partie pr\u00e9c\u00e9dente, on a souvent parl\u00e9 de \"d\u00e9placements\" de cartes. En machine, ces d\u00e9placements seront impl\u00e9ment\u00e9s sous la forme de copies d'\u00e9l\u00e9ments , en r\u00e9alisant des affectations. Algorithme du tri par insertion ALGORITHME : tri_insertion ENTR\u00c9E : \u2003\u2003 tableau : un tableau d'\u00e9l\u00e9ments SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003 POUR i ALLANT DE 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003\u2003valeur_courante \u2190 tableau[i] \u2003\u2003\u2003\u2003j \u2190 i \\(-\\) 1 \u2003\u2003\u2003\u2003 TANT QUE j \u2265 0 ET QUE tableau[j] > valeur_courante \u2003\u2003\u2003\u2003\u2003\u2003tableau[j + 1] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003j \u2190 j \\(-\\) 1 \u2003\u2003\u2003\u2003 FIN TANT QUE \u2003\u2003\u2003\u2003tableau[j + 1] \u2190 valeur_courante \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Exercice 1 D\u00e9roulez l'algorithme sur le tableau [5, 3, 1, 4, 6, 2] . Exercice 2 Pourquoi commence t-on la boucle POUR \u00e0 partir de 1 ? Expliquez \u00e0 quoi sert la 3 \u00e8me ligne de l' algorithme : j \u2190 i - 1 . Dans le TANT QUE , \u00e0 quoi sert la premi\u00e8re condition j \u2265 0 ? La deuxi\u00e8me condition tableau[j] > valeur_courante ? Pourrait t-on inverser les deux conditions ? \u00c0 quoi sert la ligne tableau[j + 1] \u2190 tableau[j] dans le TANT QUE ? Pourquoi d\u00e9cr\u00e9mente t-on (c'est-\u00e0-dire que l'on diminue de 1) la valeur de j \u00e0 chaque tour de la boucle TANT QUE ? Expliquez l' affectation tableau[j + 1] \u2190 valeur_courante apr\u00e8s la boucle TANT QUE . Tri stable Le tri par insertion , \u00e9crit comme ci-dessus, est dit \" stable \" car, en cas de valeurs identiques dans le tableau initial, leur ordre relatif n\u2019est pas modifi\u00e9 .","title":"Pr\u00e9sentation de l'algorithme"},{"location":"tri_insertion/#une-petite-animation","text":"Simulation du tri par insertion En vert : \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s En gris : \u00e9l\u00e9ments \u00e0 trier Espace m\u00e9moire: Lancer le tri Pas \u00e0 pas","title":"Une petite animation"},{"location":"tri_insertion/#implementation-en-python","text":"Maintenant que l'on a d\u00e9termin\u00e9 l' algorithme du tri par insertion , on peut l' impl\u00e9menter en Python . T\u00e9l\u00e9chargez le programme squelette (\u00e0 compl\u00e9ter) ci-dessous. Fichiers Python tri_insertion.py : programme Python avec les fonctions \u00e0 compl\u00e9ter. (\u00e0 venir) : programme Python corrig\u00e9. Module doctest Dans la docstring de la fonction tri_insertion , des tests sont pr\u00e9sents. Ces tests sont ex\u00e9cut\u00e9s par le module natif doctest . Lorsque vous ex\u00e9cutez le programme, si les tests r\u00e9ussissent, rien ne se passera . Sinon, vous obtiendrez des informations sur les tests qui ont \u00e9chou\u00e9. La fonction testmod (qui ex\u00e9cute les tests ) est appel\u00e9e dans la derni\u00e8re ligne du programme. Pour obtenir davantage d'informations sur les erreurs li\u00e9es aux tests, vous pouvez activer le mode verbeux en rempla\u00e7ant le param\u00e8tre verbose=False par verbose=True . Exercice pr\u00e9liminaire Dans les tests pr\u00e9sents dans la docstring de la fonction tri_insertion , la premi\u00e8re instruction est la suivante : >>> l = [randint(0, 99) for _ in range(10)] Expliquez ce que fait cette instruction. Exercice 1 \u00c9crivez la fonction tri_insertion . Ex\u00e9cutez le programme pour vous assurer que votre fonction soit correcte (il ne doit rien se passer). Exercice 2 \u00c9crivez la fonction tri_insertion_decroissant permettant de trier un tableau dans l'ordre d\u00e9croissant . Que faut-il changer par rapport \u00e0 la fonction tri_insertion ?","title":"Impl\u00e9mentation en Python"},{"location":"tri_selection/","text":"Le tri par s\u00e9lection Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace . Pr\u00e9sentation du tri Avec un jeu de cartes Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection Simulation avec des barres Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir L'algorithme L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique . Correction Question 1 : Question 2 et 3 : M\u00eame principe. Pour la question 3 , la comparaison se fait par ordre lexicographique (a < b < c < d < ... < x < y < z). Impl\u00e9mentation du tri par s\u00e9lection On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . Fichiers Python tri_selection.py : programme Python avec les fonctions \u00e0 compl\u00e9ter. tri_selection_corr.py : correction de l'impl\u00e9mentation des fonctions. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Correction question 1 1 - def minimum ( tableau : 'list[int]' , debut : int ) -> int : ''' Renvoie l'indice de la valeur minimale du tableau dans l'intervalle [debut, len(tableau) - 1]. :param tableau: (list[int]) un tableau d'entiers :param debut: (int) l'indice \u00e0 partir duquel on recherche le minimum :return: (int) l'indice du minimum ''' indice_min = debut # Initialiser l'indice du minimum \u00e0 debut for i in range ( debut + 1 , len ( tableau )): # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1 if tableau [ i ] < tableau [ indice_min ]: # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_min indice_min = i # Le nouvel indice du minimum est i return indice_min # Renvoyer l'indice du minimum def echanger ( tableau : 'list[int]' , i : int , j : int ) -> None : ''' Echanger deux \u00e9l\u00e9ments d'un tableau :param tableau: (list[int]) un tableau d'entiers :param i: (int) l'indice d'un \u00e9l\u00e9ment du tableau :param j: (int) l'indice d'un \u00e9l\u00e9ment du tableau ''' temp = tableau [ i ] tableau [ i ] = tableau [ j ] tableau [ j ] = temp def tri_selection ( tableau : 'list[int]' ) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) # R\u00e9cup\u00e9rer la longueur du tableau for debut in range ( 0 , n - 1 ): # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*) indice_min = minimum ( tableau , debut ) # R\u00e9cup\u00e9rer l'indice du minimum echanger ( tableau , debut , indice_min ) # Echanger les \u00e9l\u00e9ments d'indices debut et indice_min 2 - Ce n'est pas n\u00e9cessaire. Lorsqu'on ne met pas de return , cela revient \u00e0 renvoyer None (c'est-\u00e0-dire rien ). 3 - La fonction tri_selection ne renvoie rien . Une fonction qui ne renvoie rien (et qui fonctionne donc uniquement par effets de bord ) peut \u00eatre appel\u00e9e proc\u00e9dure . Attention toutefois, en Python , il n'existe pas de type 'proc\u00e9dure' , il n'existe que des fonctions (type function ). Tester ma fonction Le programme est muni de tests (lignes 13 \u00e0 22 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). R\u00e9ponse question 2 def tri_selection_tout_en_un ( tableau : 'list[int]' ) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) # R\u00e9cup\u00e9rer la longueur du tableau for debut in range ( 0 , n - 1 ): # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*) indice_min = debut # Initialiser l'indice du minimum \u00e0 debut for i in range ( debut + 1 , len ( tableau )): # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1 if tableau [ i ] < tableau [ indice_min ]: # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_min indice_min = i # Le nouvel indice du minimum est i # On effectue une permutation temp = tableau [ debut ] tableau [ debut ] = tableau [ indice_min ] tableau [ indice_min ] = temp Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . R\u00e9ponse question 3 def tri_selection_decroissant ( tableau : 'list[int]' ) -> None : ''' Effectue le tri par s\u00e9lection dans l'ordre d\u00e9croissant des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) # R\u00e9cup\u00e9rer la longueur du tableau for debut in range ( 0 , n - 1 ): # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*) indice_max = debut # Initialiser l'indice du maximum \u00e0 debut for i in range ( debut + 1 , len ( tableau )): # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1 if tableau [ i ] > tableau [ indice_max ]: # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_max indice_max = i # Le nouvel indice du minimum est i # On effectue une permutation temp = tableau [ debut ] tableau [ debut ] = tableau [ indice_max ] tableau [ indice_max ] = temp Question 4 Dans les tests , \u00e0 la ligne 19 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ? R\u00e9ponse question 4 Cette instruction cr\u00e9e une liste Python contenant 20 entiers al\u00e9atoires compris entre 0 et 100 . La cr\u00e9ation est effectu\u00e9e par compr\u00e9hension . Co\u00fbt du tri par s\u00e9lection Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . Le co\u00fbt d'un algorithme peut \u00eatre d\u00e9termin\u00e9 en comptant le nombre d' op\u00e9rations \u00e9l\u00e9mentaires r\u00e9alis\u00e9es. Ces op\u00e9rations peuvent \u00eatre par exemple des affectations , des tests , des op\u00e9rations arithm\u00e9tiques , des acc\u00e8s \u00e0 un \u00e9l\u00e9ment d'une liste , etc. Dans notre cas, on ne prendra en compte que le nombre de comparaisons entre deux \u00e9l\u00e9ments effectu\u00e9 par notre algorithme. Les comparaisons sont en l'occurence effectu\u00e9es dans l'algorithme minimum : ... SI tableau[i] < tableau[indice_min], ALORS ... On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier le tableau [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. R\u00e9ponse question 1 it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] 5 2 1 [1, 2, 3, 6, 5, 7 ] 4 3 2 [1, 2, 3, 6, 5, 7 ] 3 4 3 [1, 2, 3, 5, 6, 7 ] 2 5 4 [1, 2, 3, 5, 6, 7 ] 1 Lors de la premi\u00e8re it\u00e9ration, on effectue 5 comparaisons . Lors de la seconde it\u00e9ration, on effectue 4 comparaisons . Et ainsi de suite. Le nombre de comparaisons effectu\u00e9 au total pour un tableau de longueur \\(n = 6\\) est donc : \\[ C(6) = 5 + 4 + 3 + 2 + 1 = 15 \\] Pour un tableau de longueur \\(n = 7\\) par exemple, le nombre de comparaisons serait : \\[ C(7) = 6 + 5 + 4 + 3 + 2 + 1 = 6 + C(6) = 21 \\] Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? R\u00e9ponse question 2 Non , le tri par s\u00e9lection effectue toujours une comparaison avec tous les \u00e9l\u00e9ments de la partie non-tri\u00e9e du tableau lors de la recherche du minimum . Le nombre de comparaisons effectu\u00e9 ne d\u00e9pend que de la longueur du tableau, et non pas des \u00e9l\u00e9ments en eux-m\u00eame. Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse question 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta . On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\) . Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques. (g\u00e9n\u00e9r\u00e9 avec ce programme ) \u00c0 t\u00e9l\u00e9charger (facultatif) R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons. Terminaison du tri par s\u00e9lection Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Prouver la terminaison Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies : Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT > 0 Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante . Si les deux propositions A et B sont vraies ( \\(A \\land B\\) ), l'algorithme s'arr\u00eatera toujours . Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\) ), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas. Exemple D\u00e9montrons que la boucle POUR suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(40 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 40\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 40 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative ). On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Astuce question 1 La d\u00e9marche \u00e0 suivre est similaire \u00e0 celle de l'exemple pr\u00e9c\u00e9dent. R\u00e9-\u00e9crire la boucle POUR sous la forme d'une boucle TANT QUE . Exprimer \\(i\\) en fonction du nombre de tours de boucle \\(n\\) sous la forme d'une suite enti\u00e8re arithm\u00e9tique croissante ( \\(i_n = i_0 + r*n\\) o\u00f9 \\(i_0\\) est le terme initial et \\(r\\) est la raison ). \u00c9crire la condition du TANT QUE en partant de l'in\u00e9galit\u00e9 de d\u00e9part et de l'expression de \\(i_n\\) , et tenter d'obtenir une nouvelle in\u00e9galit\u00e9 de la forme \\(v_n > 0\\) , o\u00f9 \\(v_n\\) est une suite d'entiers strictement d\u00e9croissante . On a trouv\u00e9 un variant \\(v_n\\) : La boucle se termine ! R\u00e9ponse question 1 Pour montrer la terminaison de cet algorithme, il faut prouver la terminaison de la boucle POUR . On r\u00e9\u00e9crit la boucle POUR sous la forme d'une boucle WHILE : i = debut + 1 TANT QUE i < longueur(tableau): \u2003\u2003(instructions qui ne modifient pas la valeur de i) \u2003\u2003i = i + 1 Exprimons \\(i\\) sous la forme d'une suite arithm\u00e9tique en fonction de \\(n\\) , \\(n\\) \u00e9tant le nombre de tours de boucles effectu\u00e9 . Avant de rentrer dans la boucle, \\(n\\) vaut \\(0\\) . \\(i_n = i_0 + rn\\) avec \\(r\\) la raison de la suite arithm\u00e9tique , qui correspond au pas de la boucle. Apr\u00e8s chaque it\u00e9ration, on incr\u00e9mente \\(i\\) de 1 , donc \\(r = 1\\) . Donc \\(i_n = debut + 1 + 1*n\\) , \\(i_n = debut + 1 + n\\) . Donc, si l'on r\u00e9\u00e9crit le TANT QUE : TANT QUE i n < longueur(tableau) TANT QUE debut + 1 + n < longueur(tableau) En r\u00e9\u00e9crivant sous la forme TANT QUE VARIANT > 0 : TANT QUE 0 < longueur(tableau) - debut - 1 - n TANT QUE longueur(tableau) - debut - 1 - n > 0 On obtient une nouvelle suite arithm\u00e9tique , qu'on notera \\(v_n\\) , telle que : \\(v_n = v_0 + rn\\) avec \\(v_0\\) = \\(longueur(tableau) - debut - 1\\) et \\(r = -1\\) . \\(v_0\\) \u00e9tant un entier positif (car \\(longueur(tableau) - debut - 1\\) vaut toujours au minimum 1 ), et la raison \u00e9tant n\u00e9gative (ce qui indique que la suite est strictement d\u00e9croissante ), on peut donc dire que \\(v_n\\) est bien un variant de la boucle et que notre boucle se termine . On a prouv\u00e9 la terminaison de la seule boucle de l'algorithme, on peut donc en conclure que minimum se termine . Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Astuce question 2 On a montr\u00e9 que minimum se termine, la fonction echanger se termine (car il s'agit simplement de trois affectations), il ne reste plus qu'\u00e0 montrer que la boucle principale se termine, avec la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment. R\u00e9ponse question 2 On a pr\u00e9c\u00e9demment montr\u00e9 que minimum se terminait, et l'algorithme echanger se termine \u00e9galement (car il s'agit simplement de trois affectations ), il reste donc \u00e0 d\u00e9montrer que la boucle POUR principale de tri_selection se termine. Le principe est le m\u00eame que pr\u00e9c\u00e9demment. On r\u00e9\u00e9crit la boucle POUR sous la forme d'une boucle WHILE . ATTENTION : Il y a une variable nomm\u00e9e n dans l'algorithme qui correspond \u00e0 la longueur du tableau . Pour ne pas m\u00e9langer la longueur du tableau avec le nombre de tours de boucle effectu\u00e9 (que l'on note \u00e9galement \\(n\\) ), on remplacera le n de l'algorithme par longueur(tableau) . debut = 0 TANT QUE debut < longueur(tableau) - 1: \u2003\u2003(instructions qui ne modifient pas la valeur de debut) \u2003\u2003debut = debut + 1 Exprimons \\(debut\\) sous la forme d'une suite arithm\u00e9tique en fonction de \\(n\\) , \\(n\\) \u00e9tant le nombre de tours de boucles effectu\u00e9 . Avant de rentrer dans la boucle, \\(n\\) vaut \\(0\\) . \\(debut_n = debut_0 + rn\\) avec \\(r\\) la raison de la suite arithm\u00e9tique , qui correspond au pas de la boucle. Apr\u00e8s chaque it\u00e9ration, on incr\u00e9mente \\(debut\\) de 1 , donc \\(r = 1\\) . Donc \\(debut_n = 0 + 1*n\\) , \\(debut_n = n\\) . Donc, si l'on r\u00e9\u00e9crit le TANT QUE : TANT QUE debut n < longueur(tableau) - 1 TANT QUE n < longueur(tableau) - 1 En r\u00e9\u00e9crivant sous la forme TANT QUE VARIANT > 0 : TANT QUE longueur(tableau) - 1 - n > 0 On obtient une nouvelle suite arithm\u00e9tique , qu'on notera \\(v_n\\) , telle que : \\(v_n = v_0 + rn\\) avec \\(v_0\\) = \\(longueur(tableau) - 1\\) et \\(r = -1\\) . \\(v_0\\) \u00e9tant un entier positif (car on ne rentre dans la boucle que si \\(longueur(tableau) - 1\\) vaut au moins 1 ), et la raison \u00e9tant n\u00e9gative (ce qui indique que la suite est strictement d\u00e9croissante ), on peut donc dire que \\(v_n\\) est bien un variant de la boucle et que notre boucle se termine . On a prouv\u00e9 la terminaison de notre boucle, on peut donc en d\u00e9duire que tri_selection se termine . Preuve de correction du tri par s\u00e9lection Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e. Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? R\u00e9ponse 1 Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche . \u00bb Un tableau vide est bien tri\u00e9 , l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\) . On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . R\u00e9ponse 2 Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, debut vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). tableau[0] contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\) , on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1. k debut nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 etc. La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\) . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . Astuces question 3 Vous pouvez proc\u00e9der comme suit : D\u00e9finir l' \u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principal , notamment le nombre d'\u00e9l\u00e9ments tri\u00e9s (et l'intervalle correspondant) et le contenu de la variable debut . Supposer que la proposition \\(P_k\\) est vraie. D\u00e9tailler ce qu'il se passe lorsque l'on refait un tour de boucle . En d\u00e9duire l' \u00e9tat du syst\u00e8me \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle principale . R\u00e9ponse 3 D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale . \u00c0 la fin de l'it\u00e9ration \\(k\\) , nous avons : \\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\) une variable debut contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\) . On suppose que \\(P_k\\) est vraie , c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9 . Si l'on refait un tour de boucle, on incr\u00e9mente debut (car boucle POUR ). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\) On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l' \u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction minimum ) \u00e0 placer \u00e0 l'indice \\(k\\) . FINALEMENT , \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle : Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement). L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\) , autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9. Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s. La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e. Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection . V\u00e9rifier l'invariant avec une assertion V\u00e9rifions la validit\u00e9 de notre invariant sur la fonction tri_selection r\u00e9alis\u00e9e pr\u00e9c\u00e9demment en Python . La fonction est_trie(tableau, fin) renvoie True si les \u00e9l\u00e9ments du sous-tableau [0, fin] du tableau donn\u00e9 sont tri\u00e9s , False sinon. Si l'indice fin n'est pas donn\u00e9, la fonction v\u00e9rifie que l' enti\u00e8ret\u00e9 du tableau est tri\u00e9e . def est_trie ( tableau : list [ int ], fin : int = None ) -> bool : ''' Renvoie True si les \u00e9l\u00e9ments du tableau dans [0, fin] sont tri\u00e9s, False sinon. Si pas d'indice de fin donn\u00e9, v\u00e9rifier tout le tableau. :param tableau: (list[int]) tableau d'entiers \u00e0 v\u00e9rifier :param debut: (int) indice jusqu'auquel v\u00e9rifier les \u00e9l\u00e9ments :return: (bool) True ou False selon si les \u00e9l\u00e9ments sont tri\u00e9s ou non. ''' if fin == None : fin = len ( tableau ) - 1 return all ( tableau [ i - 1 ] <= tableau [ i ] for i in range ( 1 , fin + 1 )) Note La fonction native all(iterable) utilis\u00e9e dans la fonction ci-dessus renvoie True si tous les \u00e9l\u00e9ments de iterable sont vrais (ou s'il est vide). D\u00e8s qu'un \u00e9l\u00e9ment est faux, la fonction s'arr\u00eate et renvoie False . Question 1 Modifier la fonction tri_selection en ajoutant une assertion (avec le mot-cl\u00e9 assert ) v\u00e9rifiant, en faisant appel \u00e0 est_trie , qu'apr\u00e8s chaque it\u00e9ration de la boucle, la propri\u00e9t\u00e9 de l' invariant est respect\u00e9e. R\u00e9ponse 1 def tri_selection ( tableau : list [ int ]) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) for debut in range ( 0 , n - 1 ): indice_min = minimum ( tableau , debut ) echanger ( tableau , debut , indice_min ) assert est_trie ( tableau , debut ) \u00c0 la fin de chaque it\u00e9ration, on v\u00e9rifie avec la fonction est_trie que le sous-tableau [0, debut] est tri\u00e9 . Dans l' interpr\u00e9teur de Thonny , ex\u00e9cuter la commande suivante : >>> tri_selection ([[ 63 , 25 , 81 , 76 , 75 , 87 , 66 , 18 , 43 , 68 , 48 , 98 , 57 , 41 , 97 , 59 , 57 , 74 , 28 , 28 ]]) Question 2 Que se passe t-il ? Pourquoi ? R\u00e9ponse 2 S'il ne se passe rien, c'est normal ! Cela signifie que l'expression sp\u00e9cifi\u00e9e dans l'assertion est \u00e9valu\u00e9e \u00e0 True \u00e0 chaque fois, et donc que l' invariant est bien v\u00e9rifi\u00e9 apr\u00e8s chaque tour de boucle.","title":"Tri par s\u00e9lection"},{"location":"tri_selection/#le-tri-par-selection","text":"Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace .","title":"Le tri par s\u00e9lection"},{"location":"tri_selection/#presentation-du-tri","text":"","title":"Pr\u00e9sentation du tri"},{"location":"tri_selection/#avec-un-jeu-de-cartes","text":"Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection","title":"Avec un jeu de cartes"},{"location":"tri_selection/#simulation-avec-des-barres","text":"Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir","title":"Simulation avec des barres"},{"location":"tri_selection/#lalgorithme","text":"L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique . Correction Question 1 : Question 2 et 3 : M\u00eame principe. Pour la question 3 , la comparaison se fait par ordre lexicographique (a < b < c < d < ... < x < y < z).","title":"L'algorithme"},{"location":"tri_selection/#implementation-du-tri-par-selection","text":"On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . Fichiers Python tri_selection.py : programme Python avec les fonctions \u00e0 compl\u00e9ter. tri_selection_corr.py : correction de l'impl\u00e9mentation des fonctions. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Correction question 1 1 - def minimum ( tableau : 'list[int]' , debut : int ) -> int : ''' Renvoie l'indice de la valeur minimale du tableau dans l'intervalle [debut, len(tableau) - 1]. :param tableau: (list[int]) un tableau d'entiers :param debut: (int) l'indice \u00e0 partir duquel on recherche le minimum :return: (int) l'indice du minimum ''' indice_min = debut # Initialiser l'indice du minimum \u00e0 debut for i in range ( debut + 1 , len ( tableau )): # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1 if tableau [ i ] < tableau [ indice_min ]: # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_min indice_min = i # Le nouvel indice du minimum est i return indice_min # Renvoyer l'indice du minimum def echanger ( tableau : 'list[int]' , i : int , j : int ) -> None : ''' Echanger deux \u00e9l\u00e9ments d'un tableau :param tableau: (list[int]) un tableau d'entiers :param i: (int) l'indice d'un \u00e9l\u00e9ment du tableau :param j: (int) l'indice d'un \u00e9l\u00e9ment du tableau ''' temp = tableau [ i ] tableau [ i ] = tableau [ j ] tableau [ j ] = temp def tri_selection ( tableau : 'list[int]' ) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) # R\u00e9cup\u00e9rer la longueur du tableau for debut in range ( 0 , n - 1 ): # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*) indice_min = minimum ( tableau , debut ) # R\u00e9cup\u00e9rer l'indice du minimum echanger ( tableau , debut , indice_min ) # Echanger les \u00e9l\u00e9ments d'indices debut et indice_min 2 - Ce n'est pas n\u00e9cessaire. Lorsqu'on ne met pas de return , cela revient \u00e0 renvoyer None (c'est-\u00e0-dire rien ). 3 - La fonction tri_selection ne renvoie rien . Une fonction qui ne renvoie rien (et qui fonctionne donc uniquement par effets de bord ) peut \u00eatre appel\u00e9e proc\u00e9dure . Attention toutefois, en Python , il n'existe pas de type 'proc\u00e9dure' , il n'existe que des fonctions (type function ). Tester ma fonction Le programme est muni de tests (lignes 13 \u00e0 22 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). R\u00e9ponse question 2 def tri_selection_tout_en_un ( tableau : 'list[int]' ) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) # R\u00e9cup\u00e9rer la longueur du tableau for debut in range ( 0 , n - 1 ): # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*) indice_min = debut # Initialiser l'indice du minimum \u00e0 debut for i in range ( debut + 1 , len ( tableau )): # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1 if tableau [ i ] < tableau [ indice_min ]: # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_min indice_min = i # Le nouvel indice du minimum est i # On effectue une permutation temp = tableau [ debut ] tableau [ debut ] = tableau [ indice_min ] tableau [ indice_min ] = temp Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . R\u00e9ponse question 3 def tri_selection_decroissant ( tableau : 'list[int]' ) -> None : ''' Effectue le tri par s\u00e9lection dans l'ordre d\u00e9croissant des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) # R\u00e9cup\u00e9rer la longueur du tableau for debut in range ( 0 , n - 1 ): # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*) indice_max = debut # Initialiser l'indice du maximum \u00e0 debut for i in range ( debut + 1 , len ( tableau )): # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1 if tableau [ i ] > tableau [ indice_max ]: # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_max indice_max = i # Le nouvel indice du minimum est i # On effectue une permutation temp = tableau [ debut ] tableau [ debut ] = tableau [ indice_max ] tableau [ indice_max ] = temp Question 4 Dans les tests , \u00e0 la ligne 19 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ? R\u00e9ponse question 4 Cette instruction cr\u00e9e une liste Python contenant 20 entiers al\u00e9atoires compris entre 0 et 100 . La cr\u00e9ation est effectu\u00e9e par compr\u00e9hension .","title":"Impl\u00e9mentation du tri par s\u00e9lection"},{"location":"tri_selection/#cout-du-tri-par-selection","text":"Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . Le co\u00fbt d'un algorithme peut \u00eatre d\u00e9termin\u00e9 en comptant le nombre d' op\u00e9rations \u00e9l\u00e9mentaires r\u00e9alis\u00e9es. Ces op\u00e9rations peuvent \u00eatre par exemple des affectations , des tests , des op\u00e9rations arithm\u00e9tiques , des acc\u00e8s \u00e0 un \u00e9l\u00e9ment d'une liste , etc. Dans notre cas, on ne prendra en compte que le nombre de comparaisons entre deux \u00e9l\u00e9ments effectu\u00e9 par notre algorithme. Les comparaisons sont en l'occurence effectu\u00e9es dans l'algorithme minimum : ... SI tableau[i] < tableau[indice_min], ALORS ... On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier le tableau [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. R\u00e9ponse question 1 it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] 5 2 1 [1, 2, 3, 6, 5, 7 ] 4 3 2 [1, 2, 3, 6, 5, 7 ] 3 4 3 [1, 2, 3, 5, 6, 7 ] 2 5 4 [1, 2, 3, 5, 6, 7 ] 1 Lors de la premi\u00e8re it\u00e9ration, on effectue 5 comparaisons . Lors de la seconde it\u00e9ration, on effectue 4 comparaisons . Et ainsi de suite. Le nombre de comparaisons effectu\u00e9 au total pour un tableau de longueur \\(n = 6\\) est donc : \\[ C(6) = 5 + 4 + 3 + 2 + 1 = 15 \\] Pour un tableau de longueur \\(n = 7\\) par exemple, le nombre de comparaisons serait : \\[ C(7) = 6 + 5 + 4 + 3 + 2 + 1 = 6 + C(6) = 21 \\] Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? R\u00e9ponse question 2 Non , le tri par s\u00e9lection effectue toujours une comparaison avec tous les \u00e9l\u00e9ments de la partie non-tri\u00e9e du tableau lors de la recherche du minimum . Le nombre de comparaisons effectu\u00e9 ne d\u00e9pend que de la longueur du tableau, et non pas des \u00e9l\u00e9ments en eux-m\u00eame. Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse question 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta . On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\) . Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques. (g\u00e9n\u00e9r\u00e9 avec ce programme ) \u00c0 t\u00e9l\u00e9charger (facultatif) R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons.","title":"Co\u00fbt du tri par s\u00e9lection"},{"location":"tri_selection/#terminaison-du-tri-par-selection","text":"Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Prouver la terminaison Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies : Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT > 0 Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante . Si les deux propositions A et B sont vraies ( \\(A \\land B\\) ), l'algorithme s'arr\u00eatera toujours . Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\) ), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas. Exemple D\u00e9montrons que la boucle POUR suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(40 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 40\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 40 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative ). On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Astuce question 1 La d\u00e9marche \u00e0 suivre est similaire \u00e0 celle de l'exemple pr\u00e9c\u00e9dent. R\u00e9-\u00e9crire la boucle POUR sous la forme d'une boucle TANT QUE . Exprimer \\(i\\) en fonction du nombre de tours de boucle \\(n\\) sous la forme d'une suite enti\u00e8re arithm\u00e9tique croissante ( \\(i_n = i_0 + r*n\\) o\u00f9 \\(i_0\\) est le terme initial et \\(r\\) est la raison ). \u00c9crire la condition du TANT QUE en partant de l'in\u00e9galit\u00e9 de d\u00e9part et de l'expression de \\(i_n\\) , et tenter d'obtenir une nouvelle in\u00e9galit\u00e9 de la forme \\(v_n > 0\\) , o\u00f9 \\(v_n\\) est une suite d'entiers strictement d\u00e9croissante . On a trouv\u00e9 un variant \\(v_n\\) : La boucle se termine ! R\u00e9ponse question 1 Pour montrer la terminaison de cet algorithme, il faut prouver la terminaison de la boucle POUR . On r\u00e9\u00e9crit la boucle POUR sous la forme d'une boucle WHILE : i = debut + 1 TANT QUE i < longueur(tableau): \u2003\u2003(instructions qui ne modifient pas la valeur de i) \u2003\u2003i = i + 1 Exprimons \\(i\\) sous la forme d'une suite arithm\u00e9tique en fonction de \\(n\\) , \\(n\\) \u00e9tant le nombre de tours de boucles effectu\u00e9 . Avant de rentrer dans la boucle, \\(n\\) vaut \\(0\\) . \\(i_n = i_0 + rn\\) avec \\(r\\) la raison de la suite arithm\u00e9tique , qui correspond au pas de la boucle. Apr\u00e8s chaque it\u00e9ration, on incr\u00e9mente \\(i\\) de 1 , donc \\(r = 1\\) . Donc \\(i_n = debut + 1 + 1*n\\) , \\(i_n = debut + 1 + n\\) . Donc, si l'on r\u00e9\u00e9crit le TANT QUE : TANT QUE i n < longueur(tableau) TANT QUE debut + 1 + n < longueur(tableau) En r\u00e9\u00e9crivant sous la forme TANT QUE VARIANT > 0 : TANT QUE 0 < longueur(tableau) - debut - 1 - n TANT QUE longueur(tableau) - debut - 1 - n > 0 On obtient une nouvelle suite arithm\u00e9tique , qu'on notera \\(v_n\\) , telle que : \\(v_n = v_0 + rn\\) avec \\(v_0\\) = \\(longueur(tableau) - debut - 1\\) et \\(r = -1\\) . \\(v_0\\) \u00e9tant un entier positif (car \\(longueur(tableau) - debut - 1\\) vaut toujours au minimum 1 ), et la raison \u00e9tant n\u00e9gative (ce qui indique que la suite est strictement d\u00e9croissante ), on peut donc dire que \\(v_n\\) est bien un variant de la boucle et que notre boucle se termine . On a prouv\u00e9 la terminaison de la seule boucle de l'algorithme, on peut donc en conclure que minimum se termine . Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Astuce question 2 On a montr\u00e9 que minimum se termine, la fonction echanger se termine (car il s'agit simplement de trois affectations), il ne reste plus qu'\u00e0 montrer que la boucle principale se termine, avec la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment. R\u00e9ponse question 2 On a pr\u00e9c\u00e9demment montr\u00e9 que minimum se terminait, et l'algorithme echanger se termine \u00e9galement (car il s'agit simplement de trois affectations ), il reste donc \u00e0 d\u00e9montrer que la boucle POUR principale de tri_selection se termine. Le principe est le m\u00eame que pr\u00e9c\u00e9demment. On r\u00e9\u00e9crit la boucle POUR sous la forme d'une boucle WHILE . ATTENTION : Il y a une variable nomm\u00e9e n dans l'algorithme qui correspond \u00e0 la longueur du tableau . Pour ne pas m\u00e9langer la longueur du tableau avec le nombre de tours de boucle effectu\u00e9 (que l'on note \u00e9galement \\(n\\) ), on remplacera le n de l'algorithme par longueur(tableau) . debut = 0 TANT QUE debut < longueur(tableau) - 1: \u2003\u2003(instructions qui ne modifient pas la valeur de debut) \u2003\u2003debut = debut + 1 Exprimons \\(debut\\) sous la forme d'une suite arithm\u00e9tique en fonction de \\(n\\) , \\(n\\) \u00e9tant le nombre de tours de boucles effectu\u00e9 . Avant de rentrer dans la boucle, \\(n\\) vaut \\(0\\) . \\(debut_n = debut_0 + rn\\) avec \\(r\\) la raison de la suite arithm\u00e9tique , qui correspond au pas de la boucle. Apr\u00e8s chaque it\u00e9ration, on incr\u00e9mente \\(debut\\) de 1 , donc \\(r = 1\\) . Donc \\(debut_n = 0 + 1*n\\) , \\(debut_n = n\\) . Donc, si l'on r\u00e9\u00e9crit le TANT QUE : TANT QUE debut n < longueur(tableau) - 1 TANT QUE n < longueur(tableau) - 1 En r\u00e9\u00e9crivant sous la forme TANT QUE VARIANT > 0 : TANT QUE longueur(tableau) - 1 - n > 0 On obtient une nouvelle suite arithm\u00e9tique , qu'on notera \\(v_n\\) , telle que : \\(v_n = v_0 + rn\\) avec \\(v_0\\) = \\(longueur(tableau) - 1\\) et \\(r = -1\\) . \\(v_0\\) \u00e9tant un entier positif (car on ne rentre dans la boucle que si \\(longueur(tableau) - 1\\) vaut au moins 1 ), et la raison \u00e9tant n\u00e9gative (ce qui indique que la suite est strictement d\u00e9croissante ), on peut donc dire que \\(v_n\\) est bien un variant de la boucle et que notre boucle se termine . On a prouv\u00e9 la terminaison de notre boucle, on peut donc en d\u00e9duire que tri_selection se termine .","title":"Terminaison du tri par s\u00e9lection"},{"location":"tri_selection/#preuve-de-correction-du-tri-par-selection","text":"Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e. Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? R\u00e9ponse 1 Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche . \u00bb Un tableau vide est bien tri\u00e9 , l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\) . On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . R\u00e9ponse 2 Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, debut vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). tableau[0] contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\) , on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1. k debut nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 etc. La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\) . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . Astuces question 3 Vous pouvez proc\u00e9der comme suit : D\u00e9finir l' \u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principal , notamment le nombre d'\u00e9l\u00e9ments tri\u00e9s (et l'intervalle correspondant) et le contenu de la variable debut . Supposer que la proposition \\(P_k\\) est vraie. D\u00e9tailler ce qu'il se passe lorsque l'on refait un tour de boucle . En d\u00e9duire l' \u00e9tat du syst\u00e8me \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle principale . R\u00e9ponse 3 D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale . \u00c0 la fin de l'it\u00e9ration \\(k\\) , nous avons : \\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\) une variable debut contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\) . On suppose que \\(P_k\\) est vraie , c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9 . Si l'on refait un tour de boucle, on incr\u00e9mente debut (car boucle POUR ). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\) On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l' \u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction minimum ) \u00e0 placer \u00e0 l'indice \\(k\\) . FINALEMENT , \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle : Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement). L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\) , autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9. Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s. La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e. Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection .","title":"Preuve de correction du tri par s\u00e9lection"},{"location":"tri_selection/#verifier-linvariant-avec-une-assertion","text":"V\u00e9rifions la validit\u00e9 de notre invariant sur la fonction tri_selection r\u00e9alis\u00e9e pr\u00e9c\u00e9demment en Python . La fonction est_trie(tableau, fin) renvoie True si les \u00e9l\u00e9ments du sous-tableau [0, fin] du tableau donn\u00e9 sont tri\u00e9s , False sinon. Si l'indice fin n'est pas donn\u00e9, la fonction v\u00e9rifie que l' enti\u00e8ret\u00e9 du tableau est tri\u00e9e . def est_trie ( tableau : list [ int ], fin : int = None ) -> bool : ''' Renvoie True si les \u00e9l\u00e9ments du tableau dans [0, fin] sont tri\u00e9s, False sinon. Si pas d'indice de fin donn\u00e9, v\u00e9rifier tout le tableau. :param tableau: (list[int]) tableau d'entiers \u00e0 v\u00e9rifier :param debut: (int) indice jusqu'auquel v\u00e9rifier les \u00e9l\u00e9ments :return: (bool) True ou False selon si les \u00e9l\u00e9ments sont tri\u00e9s ou non. ''' if fin == None : fin = len ( tableau ) - 1 return all ( tableau [ i - 1 ] <= tableau [ i ] for i in range ( 1 , fin + 1 )) Note La fonction native all(iterable) utilis\u00e9e dans la fonction ci-dessus renvoie True si tous les \u00e9l\u00e9ments de iterable sont vrais (ou s'il est vide). D\u00e8s qu'un \u00e9l\u00e9ment est faux, la fonction s'arr\u00eate et renvoie False . Question 1 Modifier la fonction tri_selection en ajoutant une assertion (avec le mot-cl\u00e9 assert ) v\u00e9rifiant, en faisant appel \u00e0 est_trie , qu'apr\u00e8s chaque it\u00e9ration de la boucle, la propri\u00e9t\u00e9 de l' invariant est respect\u00e9e. R\u00e9ponse 1 def tri_selection ( tableau : list [ int ]) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) for debut in range ( 0 , n - 1 ): indice_min = minimum ( tableau , debut ) echanger ( tableau , debut , indice_min ) assert est_trie ( tableau , debut ) \u00c0 la fin de chaque it\u00e9ration, on v\u00e9rifie avec la fonction est_trie que le sous-tableau [0, debut] est tri\u00e9 . Dans l' interpr\u00e9teur de Thonny , ex\u00e9cuter la commande suivante : >>> tri_selection ([[ 63 , 25 , 81 , 76 , 75 , 87 , 66 , 18 , 43 , 68 , 48 , 98 , 57 , 41 , 97 , 59 , 57 , 74 , 28 , 28 ]]) Question 2 Que se passe t-il ? Pourquoi ? R\u00e9ponse 2 S'il ne se passe rien, c'est normal ! Cela signifie que l'expression sp\u00e9cifi\u00e9e dans l'assertion est \u00e9valu\u00e9e \u00e0 True \u00e0 chaque fois, et donc que l' invariant est bien v\u00e9rifi\u00e9 apr\u00e8s chaque tour de boucle.","title":"V\u00e9rifier l'invariant avec une assertion"},{"location":"tri_selection_correction/","text":"Le tri par s\u00e9lection Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace . Pr\u00e9sentation du tri Avec un jeu de cartes Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection Simulation avec des barres Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir L'algorithme L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique . Impl\u00e9mentation du tri par s\u00e9lection On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Tester ma fonction Le programme est muni de tests (lignes 13 \u00e0 22 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . Question 4 Dans les tests , \u00e0 la ligne 19 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ? Co\u00fbt du tri par s\u00e9lection Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta . On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\) . Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques. (g\u00e9n\u00e9r\u00e9 avec ce programme ) \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons. Terminaison du tri par s\u00e9lection Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Prouver la terminaison Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies : Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT > 0 Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante . Si les deux propositions A et B sont vraies ( \\(A \\land B\\) ), l'algorithme s'arr\u00eatera toujours . Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\) ), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas. Exemple D\u00e9montrons que la boucle POUR suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(60 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative ). On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Astuce question 1 La d\u00e9marche \u00e0 suivre est similaire \u00e0 celle de l'exemple pr\u00e9c\u00e9dent. R\u00e9-\u00e9crire la boucle POUR sous la forme d'une boucle TANT QUE . Exprimer \\(i\\) en fonction du nombre de tours de boucle \\(n\\) sous la forme d'une suite enti\u00e8re arithm\u00e9tique croissante ( \\(i_n = i_0 + r*n\\) o\u00f9 \\(i_0\\) est le terme initial et \\(r\\) est la raison ). \u00c9crire la condition du TANT QUE en partant de l'in\u00e9galit\u00e9 de d\u00e9part et de l'expression de \\(i_n\\) , et tenter d'obtenir une nouvelle in\u00e9galit\u00e9 de la forme \\(v_n > 0\\) , o\u00f9 \\(v_n\\) est une suite d'entiers strictement d\u00e9croissante . On a trouv\u00e9 un variant \\(v_n\\) : La boucle se termine ! Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Astuce question 2 On a montr\u00e9 que minimum se termine, la fonction echanger se termine (car il s'agit simplement de trois affectations), il ne reste plus qu'\u00e0 montrer que la boucle principale se termine, avec la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment. Preuve de correction du tri par s\u00e9lection Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e. Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? R\u00e9ponse 1 Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche . \u00bb Un tableau vide est bien tri\u00e9 , l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\) . On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . R\u00e9ponse 2 Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, debut vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). tableau[0] contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\) , on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1. k debut nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 etc. La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\) . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . Astuces question 3 Vous pouvez proc\u00e9der comme suit : D\u00e9finir l' \u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principal , notamment le nombre d'\u00e9l\u00e9ments tri\u00e9s (et l'intervalle correspondant) et le contenu de la variable debut . Supposer que la proposition \\(P_k\\) est vraie. D\u00e9tailler ce qu'il se passe lorsque l'on refait un tour de boucle . En d\u00e9duire l' \u00e9tat du syst\u00e8me \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle principale . R\u00e9ponse 3 D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale . \u00c0 la fin de l'it\u00e9ration \\(k\\) , nous avons : \\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\) une variable debut contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\) . On suppose que \\(P_k\\) est vraie , c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9 . Si l'on refait un tour de boucle, on incr\u00e9mente debut (car boucle POUR ). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\) On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l' \u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction minimum ) \u00e0 placer \u00e0 l'indice \\(k\\) . FINALEMENT , \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle : Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement). L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\) , autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9. Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s. La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e. Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection . V\u00e9rifier l'invariant avec une assertion V\u00e9rifions la validit\u00e9 de notre invariant sur la fonction tri_selection r\u00e9alis\u00e9e pr\u00e9c\u00e9demment en Python . La fonction est_trie(tableau, fin) renvoie True si les \u00e9l\u00e9ments du sous-tableau [0, fin] du tableau donn\u00e9 sont tri\u00e9s , False sinon. Si l'indice fin n'est pas donn\u00e9, la fonction v\u00e9rifie que l' enti\u00e8ret\u00e9 du tableau est tri\u00e9e . def est_trie ( tableau : list [ int ], fin : int = None ) -> bool : ''' Renvoie True si les \u00e9l\u00e9ments du tableau dans [0, fin] sont tri\u00e9s, False sinon. Si pas d'indice de fin donn\u00e9, v\u00e9rifier tout le tableau. :param tableau: (list[int]) tableau d'entiers \u00e0 v\u00e9rifier :param debut: (int) indice jusqu'auquel v\u00e9rifier les \u00e9l\u00e9ments :return: (bool) True ou False selon si les \u00e9l\u00e9ments sont tri\u00e9s ou non. ''' if fin == None : fin = len ( tableau ) - 1 return all ( tableau [ i - 1 ] <= tableau [ i ] for i in range ( 1 , fin + 1 )) Note La fonction native all(iterable) utilis\u00e9e dans la fonction ci-dessus renvoie True si tous les \u00e9l\u00e9ments de iterable sont vrais (ou s'il est vide). D\u00e8s qu'un \u00e9l\u00e9ment est faux, la fonction s'arr\u00eate et renvoie False . Question 1 Modifier la fonction tri_selection en ajoutant une assertion (avec le mot-cl\u00e9 assert ) v\u00e9rifiant, en faisant appel \u00e0 est_trie , qu'apr\u00e8s chaque it\u00e9ration de la boucle, la propri\u00e9t\u00e9 de l' invariant est respect\u00e9e. R\u00e9ponse 1 def tri_selection ( tableau : list [ int ]) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) for debut in range ( 0 , n - 1 ): indice_min = minimum ( tableau , debut ) echanger ( tableau , debut , indice_min ) assert est_trie ( tableau , debut ) \u00c0 la fin de chaque it\u00e9ration, on v\u00e9rifie avec la fonction est_trie que le sous-tableau [0, debut] est tri\u00e9 . Dans l' interpr\u00e9teur de Thonny , ex\u00e9cuter la commande suivante : >>> tri_selection ([[ 63 , 25 , 81 , 76 , 75 , 87 , 66 , 18 , 43 , 68 , 48 , 98 , 57 , 41 , 97 , 59 , 57 , 74 , 28 , 28 ]]) Question 2 Que se passe t-il ? Pourquoi ? R\u00e9ponse 2 S'il ne se passe rien, c'est normal ! Cela signifie que l'expression sp\u00e9cifi\u00e9e dans l'assertion est \u00e9valu\u00e9e \u00e0 True \u00e0 chaque fois, et donc que l' invariant est bien v\u00e9rifi\u00e9 apr\u00e8s chaque tour de boucle.","title":"Le tri par s\u00e9lection"},{"location":"tri_selection_correction/#le-tri-par-selection","text":"Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace .","title":"Le tri par s\u00e9lection"},{"location":"tri_selection_correction/#presentation-du-tri","text":"","title":"Pr\u00e9sentation du tri"},{"location":"tri_selection_correction/#avec-un-jeu-de-cartes","text":"Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection","title":"Avec un jeu de cartes"},{"location":"tri_selection_correction/#simulation-avec-des-barres","text":"Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir","title":"Simulation avec des barres"},{"location":"tri_selection_correction/#lalgorithme","text":"L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique .","title":"L'algorithme"},{"location":"tri_selection_correction/#implementation-du-tri-par-selection","text":"On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Tester ma fonction Le programme est muni de tests (lignes 13 \u00e0 22 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . Question 4 Dans les tests , \u00e0 la ligne 19 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ?","title":"Impl\u00e9mentation du tri par s\u00e9lection"},{"location":"tri_selection_correction/#cout-du-tri-par-selection","text":"Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta . On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\) . Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques. (g\u00e9n\u00e9r\u00e9 avec ce programme ) \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons.","title":"Co\u00fbt du tri par s\u00e9lection"},{"location":"tri_selection_correction/#terminaison-du-tri-par-selection","text":"Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Prouver la terminaison Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies : Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT > 0 Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante . Si les deux propositions A et B sont vraies ( \\(A \\land B\\) ), l'algorithme s'arr\u00eatera toujours . Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\) ), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas. Exemple D\u00e9montrons que la boucle POUR suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(60 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative ). On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Astuce question 1 La d\u00e9marche \u00e0 suivre est similaire \u00e0 celle de l'exemple pr\u00e9c\u00e9dent. R\u00e9-\u00e9crire la boucle POUR sous la forme d'une boucle TANT QUE . Exprimer \\(i\\) en fonction du nombre de tours de boucle \\(n\\) sous la forme d'une suite enti\u00e8re arithm\u00e9tique croissante ( \\(i_n = i_0 + r*n\\) o\u00f9 \\(i_0\\) est le terme initial et \\(r\\) est la raison ). \u00c9crire la condition du TANT QUE en partant de l'in\u00e9galit\u00e9 de d\u00e9part et de l'expression de \\(i_n\\) , et tenter d'obtenir une nouvelle in\u00e9galit\u00e9 de la forme \\(v_n > 0\\) , o\u00f9 \\(v_n\\) est une suite d'entiers strictement d\u00e9croissante . On a trouv\u00e9 un variant \\(v_n\\) : La boucle se termine ! Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Astuce question 2 On a montr\u00e9 que minimum se termine, la fonction echanger se termine (car il s'agit simplement de trois affectations), il ne reste plus qu'\u00e0 montrer que la boucle principale se termine, avec la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment.","title":"Terminaison du tri par s\u00e9lection"},{"location":"tri_selection_correction/#preuve-de-correction-du-tri-par-selection","text":"Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e. Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? R\u00e9ponse 1 Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche . \u00bb Un tableau vide est bien tri\u00e9 , l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\) . On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . R\u00e9ponse 2 Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, debut vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). tableau[0] contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\) , on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1. k debut nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 etc. La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\) . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . Astuces question 3 Vous pouvez proc\u00e9der comme suit : D\u00e9finir l' \u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principal , notamment le nombre d'\u00e9l\u00e9ments tri\u00e9s (et l'intervalle correspondant) et le contenu de la variable debut . Supposer que la proposition \\(P_k\\) est vraie. D\u00e9tailler ce qu'il se passe lorsque l'on refait un tour de boucle . En d\u00e9duire l' \u00e9tat du syst\u00e8me \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle principale . R\u00e9ponse 3 D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale . \u00c0 la fin de l'it\u00e9ration \\(k\\) , nous avons : \\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\) une variable debut contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\) . On suppose que \\(P_k\\) est vraie , c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9 . Si l'on refait un tour de boucle, on incr\u00e9mente debut (car boucle POUR ). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\) On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l' \u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction minimum ) \u00e0 placer \u00e0 l'indice \\(k\\) . FINALEMENT , \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle : Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement). L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\) , autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9. Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s. La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e. Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection .","title":"Preuve de correction du tri par s\u00e9lection"},{"location":"tri_selection_correction/#verifier-linvariant-avec-une-assertion","text":"V\u00e9rifions la validit\u00e9 de notre invariant sur la fonction tri_selection r\u00e9alis\u00e9e pr\u00e9c\u00e9demment en Python . La fonction est_trie(tableau, fin) renvoie True si les \u00e9l\u00e9ments du sous-tableau [0, fin] du tableau donn\u00e9 sont tri\u00e9s , False sinon. Si l'indice fin n'est pas donn\u00e9, la fonction v\u00e9rifie que l' enti\u00e8ret\u00e9 du tableau est tri\u00e9e . def est_trie ( tableau : list [ int ], fin : int = None ) -> bool : ''' Renvoie True si les \u00e9l\u00e9ments du tableau dans [0, fin] sont tri\u00e9s, False sinon. Si pas d'indice de fin donn\u00e9, v\u00e9rifier tout le tableau. :param tableau: (list[int]) tableau d'entiers \u00e0 v\u00e9rifier :param debut: (int) indice jusqu'auquel v\u00e9rifier les \u00e9l\u00e9ments :return: (bool) True ou False selon si les \u00e9l\u00e9ments sont tri\u00e9s ou non. ''' if fin == None : fin = len ( tableau ) - 1 return all ( tableau [ i - 1 ] <= tableau [ i ] for i in range ( 1 , fin + 1 )) Note La fonction native all(iterable) utilis\u00e9e dans la fonction ci-dessus renvoie True si tous les \u00e9l\u00e9ments de iterable sont vrais (ou s'il est vide). D\u00e8s qu'un \u00e9l\u00e9ment est faux, la fonction s'arr\u00eate et renvoie False . Question 1 Modifier la fonction tri_selection en ajoutant une assertion (avec le mot-cl\u00e9 assert ) v\u00e9rifiant, en faisant appel \u00e0 est_trie , qu'apr\u00e8s chaque it\u00e9ration de la boucle, la propri\u00e9t\u00e9 de l' invariant est respect\u00e9e. R\u00e9ponse 1 def tri_selection ( tableau : list [ int ]) -> None : ''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9. :param tableau: (list[int]) un tableau d'entiers \u00e0 trier ''' n = len ( tableau ) for debut in range ( 0 , n - 1 ): indice_min = minimum ( tableau , debut ) echanger ( tableau , debut , indice_min ) assert est_trie ( tableau , debut ) \u00c0 la fin de chaque it\u00e9ration, on v\u00e9rifie avec la fonction est_trie que le sous-tableau [0, debut] est tri\u00e9 . Dans l' interpr\u00e9teur de Thonny , ex\u00e9cuter la commande suivante : >>> tri_selection ([[ 63 , 25 , 81 , 76 , 75 , 87 , 66 , 18 , 43 , 68 , 48 , 98 , 57 , 41 , 97 , 59 , 57 , 74 , 28 , 28 ]]) Question 2 Que se passe t-il ? Pourquoi ? R\u00e9ponse 2 S'il ne se passe rien, c'est normal ! Cela signifie que l'expression sp\u00e9cifi\u00e9e dans l'assertion est \u00e9valu\u00e9e \u00e0 True \u00e0 chaque fois, et donc que l' invariant est bien v\u00e9rifi\u00e9 apr\u00e8s chaque tour de boucle.","title":"V\u00e9rifier l'invariant avec une assertion"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tri par s\u00e9lection et par insertion Bienvenue, ce site est d\u00e9di\u00e9 au cours de premi\u00e8re NSI sur le tri par s\u00e9lection et par insertion . COURS : Cours tri par s\u00e9lection Cours tri par insertion (\u00e0 venir) Demerville Erwan Me contacter : demerville.erwan@gmail.com","title":"Tri par s\u00e9lection et par insertion"},{"location":"#tri-par-selection-et-par-insertion","text":"Bienvenue, ce site est d\u00e9di\u00e9 au cours de premi\u00e8re NSI sur le tri par s\u00e9lection et par insertion . COURS : Cours tri par s\u00e9lection Cours tri par insertion (\u00e0 venir) Demerville Erwan Me contacter : demerville.erwan@gmail.com","title":"Tri par s\u00e9lection et par insertion"},{"location":"activite_preliminaire/","text":"Activit\u00e9 pr\u00e9liminaire sur les tris L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus. On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Partie 1 : Exp\u00e9rimentation La zone de jeu est constitu\u00e9e : d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7 , d'une zone temporaire dans laquelle on peut stocker l' indice ou la valeur d'une carte. Zone de jeu \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : Disposer une suite de 8 cartes arbitrairement choisies sur votre table. \u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes . Vous l'\u00e9crirez sur un bloc-note https://collab.infoforall.fr/ . Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'elle fonctionne toujours. Important Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes : comparer les valeurs de deux cartes , permuter (\u00e9changer) deux cartes , copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement), vous pouvez utiliser des conditions ( SI ... , SINON ) et des boucles ( TANT QUE , POUR ... ALLANT DE ... A ... ). Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter : vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re), si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal), votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel. Partie 2 : Bilan des strat\u00e9gies Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes . \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement . Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas. Partie 3 : Tri par s\u00e9lection Principe du tri par s\u00e9lection Le tri par s\u00e9lection se d\u00e9roule comme suit : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la liste. Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite ) ayant cette valeur. \u00c0 faire 1 D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement. On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine , c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite. Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine , la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations , des comparaisons et des conditions . Recherche de la plus faible carte Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 : Stocker l' indice \\(i\\) dans la zone temporaire . En parcourant la suite de cartes de gauche \u00e0 droite , \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite : Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire . SI une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire , remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l' indice de cette carte . Renvoyer enfin l' indice contenu dans la zone temporaire . \u00c0 faire 2 Vous devez \u00e0 pr\u00e9sent : D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection , en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies. Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es. Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?","title":"Activit\u00e9 pr\u00e9liminaire sur les tris"},{"location":"activite_preliminaire/#activite-preliminaire-sur-les-tris","text":"L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus. On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.","title":"Activit\u00e9 pr\u00e9liminaire sur les tris"},{"location":"activite_preliminaire/#partie-1-experimentation","text":"La zone de jeu est constitu\u00e9e : d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7 , d'une zone temporaire dans laquelle on peut stocker l' indice ou la valeur d'une carte. Zone de jeu \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : Disposer une suite de 8 cartes arbitrairement choisies sur votre table. \u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes . Vous l'\u00e9crirez sur un bloc-note https://collab.infoforall.fr/ . Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'elle fonctionne toujours. Important Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes : comparer les valeurs de deux cartes , permuter (\u00e9changer) deux cartes , copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement), vous pouvez utiliser des conditions ( SI ... , SINON ) et des boucles ( TANT QUE , POUR ... ALLANT DE ... A ... ). Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter : vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re), si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal), votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel.","title":"Partie 1 : Exp\u00e9rimentation"},{"location":"activite_preliminaire/#partie-2-bilan-des-strategies","text":"Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes . \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement . Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas.","title":"Partie 2 : Bilan des strat\u00e9gies"},{"location":"activite_preliminaire/#partie-3-tri-par-selection","text":"Principe du tri par s\u00e9lection Le tri par s\u00e9lection se d\u00e9roule comme suit : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la liste. Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite ) ayant cette valeur. \u00c0 faire 1 D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement. On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine , c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite. Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine , la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations , des comparaisons et des conditions . Recherche de la plus faible carte Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 : Stocker l' indice \\(i\\) dans la zone temporaire . En parcourant la suite de cartes de gauche \u00e0 droite , \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite : Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire . SI une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire , remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l' indice de cette carte . Renvoyer enfin l' indice contenu dans la zone temporaire . \u00c0 faire 2 Vous devez \u00e0 pr\u00e9sent : D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection , en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies. Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es. Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?","title":"Partie 3 : Tri par s\u00e9lection"},{"location":"tri_selection/","text":"Le tri par s\u00e9lection Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace . Pr\u00e9sentation du tri Avec un jeu de cartes Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection Simulation avec des barres Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir L'algorithme L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique . Impl\u00e9mentation du tri par s\u00e9lection On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Tester ma fonction Le programme est muni de tests (lignes 12 \u00e0 21 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . Question 4 Dans les tests , \u00e0 la ligne 18 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ? Co\u00fbt du tri par s\u00e9lection Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Source : https://buzut.net/cours/computer-science/time-complexity \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons. Terminaison du tri par s\u00e9lection Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Exemple D\u00e9montrons que la boucle for suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(60 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = 5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit bien d'une quantit\u00e9 enti\u00e8re , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle. On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Preuve de correction du tri par s\u00e9lection Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : \u00ab par r\u00e9currence, la proposition est vraie pour tout entier \\(k \\ge 0\\) . \u00bb Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection .","title":"Tri par s\u00e9lection"},{"location":"tri_selection/#le-tri-par-selection","text":"Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace .","title":"Le tri par s\u00e9lection"},{"location":"tri_selection/#presentation-du-tri","text":"","title":"Pr\u00e9sentation du tri"},{"location":"tri_selection/#avec-un-jeu-de-cartes","text":"Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection","title":"Avec un jeu de cartes"},{"location":"tri_selection/#simulation-avec-des-barres","text":"Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir","title":"Simulation avec des barres"},{"location":"tri_selection/#lalgorithme","text":"L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique .","title":"L'algorithme"},{"location":"tri_selection/#implementation-du-tri-par-selection","text":"On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Tester ma fonction Le programme est muni de tests (lignes 12 \u00e0 21 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . Question 4 Dans les tests , \u00e0 la ligne 18 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ?","title":"Impl\u00e9mentation du tri par s\u00e9lection"},{"location":"tri_selection/#cout-du-tri-par-selection","text":"Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Source : https://buzut.net/cours/computer-science/time-complexity \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons.","title":"Co\u00fbt du tri par s\u00e9lection"},{"location":"tri_selection/#terminaison-du-tri-par-selection","text":"Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Exemple D\u00e9montrons que la boucle for suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(60 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = 5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit bien d'une quantit\u00e9 enti\u00e8re , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle. On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME","title":"Terminaison du tri par s\u00e9lection"},{"location":"tri_selection/#preuve-de-correction-du-tri-par-selection","text":"Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : \u00ab par r\u00e9currence, la proposition est vraie pour tout entier \\(k \\ge 0\\) . \u00bb Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection .","title":"Preuve de correction du tri par s\u00e9lection"},{"location":"tri_selection_correction/","text":"Le tri par s\u00e9lection Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace . Pr\u00e9sentation du tri Avec un jeu de cartes Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection Simulation avec des barres Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir L'algorithme L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique . Impl\u00e9mentation du tri par s\u00e9lection On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Tester ma fonction Le programme est muni de tests (lignes 12 \u00e0 21 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . Question 4 Dans les tests , \u00e0 la ligne 18 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ? Co\u00fbt du tri par s\u00e9lection Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta . On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\) . Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Source : https://buzut.net/cours/computer-science/time-complexity \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons. Terminaison du tri par s\u00e9lection Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Exemple D\u00e9montrons que la boucle for suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(60 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = 5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit bien d'une quantit\u00e9 enti\u00e8re , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle. On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Preuve de correction du tri par s\u00e9lection Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : \u00ab par r\u00e9currence, la proposition est vraie pour tout entier \\(k \\ge 0\\) . \u00bb Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? R\u00e9ponse 1 Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche . \u00bb Un tableau vide est bien tri\u00e9 , l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\) . On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . R\u00e9ponse 2 Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, debut vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). tableau[0] contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\) , on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1. k debut nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 etc. La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\) . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . R\u00e9ponse 3 D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale . \u00c0 la fin de l'it\u00e9ration \\(k\\) , nous avons : \\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\) une variable debut contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\) . On suppose que \\(P_k\\) est vraie , c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9 . Si l'on refait un tour de boucle, on incr\u00e9mente debut (car boucle POUR ). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\) On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l' \u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction minimum ) \u00e0 placer \u00e0 l'indice \\(k\\) . FINALEMENT , \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle : Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement). L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\) , autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9. Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s. La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e. Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection .","title":"Le tri par s\u00e9lection"},{"location":"tri_selection_correction/#le-tri-par-selection","text":"Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace .","title":"Le tri par s\u00e9lection"},{"location":"tri_selection_correction/#presentation-du-tri","text":"","title":"Pr\u00e9sentation du tri"},{"location":"tri_selection_correction/#avec-un-jeu-de-cartes","text":"Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel. On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple : On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Principe du tri par s\u00e9lection Le principe du tri par s\u00e9lection du minimum est le suivant : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la suite. Exemple de d\u00e9roulement du tri par s\u00e9lection","title":"Avec un jeu de cartes"},{"location":"tri_selection_correction/#simulation-avec-des-barres","text":"Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande . Simulation du tri par s\u00e9lection du minimum Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir","title":"Simulation avec des barres"},{"location":"tri_selection_correction/#lalgorithme","text":"L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non. Tri en place Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes : l'algorithme principal tri_selection(tableau) permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut \u2003\u2003\u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Note La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple : Avec le tableau [2, 4a, 4b, 3, 7, 5] , l'ordre des \u00e9l\u00e9ments de valeur 4 n'est pas conserv\u00e9. S\u00e9lection du maximum Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e , puis de la partie tri\u00e9e . \u00c0 vous de jouer Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [7, 1, 5, 3, 8, 5] en vous aidant du tableau suivant : Question 2 : Faites de m\u00eame sur le tableau [5, 3, 1, 4, 6, 2] . Question 3 : M\u00eame chose cette fois avec le tableau ['b', 'e', 'c', 'w', 'p', 'q'] . On utilisera l'ordre lexicographique .","title":"L'algorithme"},{"location":"tri_selection_correction/#implementation-du-tri-par-selection","text":"On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python . Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type list ). Question pr\u00e9liminaire Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python. Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant . \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter. Question 1 Compl\u00e9ter les fonctions : minimum(tableau, debut) : renvoie l' indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle [debut, len(tableau) - 1] . echanger(tableau, i, j) : \u00e9change les \u00e9l\u00e9ments d'indices i et j du tableau tableau . Compl\u00e9ter la fonction tri_selection(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau tableau donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes. Est-il n\u00e9cessaire de mettre un return None ? Pourquoi ? Peut-on dire que la fonction tri_selection est une proc\u00e9dure ? Pourquoi ? Tester ma fonction Le programme est muni de tests (lignes 12 \u00e0 21 ) ex\u00e9cut\u00e9s par le module Doctest . Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9. (Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.) Question 2 Compl\u00e9ter la fonction tri_selection_tout_en_un(tableau) en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction ). Question 3 \u00c9crire la fonction tri_selection_decroissant(tableau) qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l' ordre d\u00e9croissant . Question 4 Dans les tests , \u00e0 la ligne 18 , on trouve l'instruction l = [randint(0, 100) for _ in range(20)] . Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ?","title":"Impl\u00e9mentation du tri par s\u00e9lection"},{"location":"tri_selection_correction/#cout-du-tri-par-selection","text":"Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection . On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 1 On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste [3, 7, 1, 6, 5, 2] . Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale POUR debut ALLANT DE 0 \u00c0 n - 2 , c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme minimum(tableau, debut) pour chaque valeur de debut de 0 \u00e0 n , n \u00e9tant la longueur du tableau . it\u00e9ration k = debut tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2 ] ... 2 1 [1, 2, 3, 6, 5, 7 ] ... 3 2 [1, 2, 3, 6, 5, 7 ] ... 4 3 [1, 2, 3, 5, 6, 7 ] ... 5 4 [1, 2, 3, 5, 6, 7 ] ... Calculer le nombre de comparaisons au total , not\u00e9 \\(C(6)\\) , effectu\u00e9 pour trier ce tableau. Question 2 Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ? Question 3 Calculer le nombre de comparaisons , not\u00e9 \\(C(n)\\) , pour un tableau de taille \\(n\\) . Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.) Calcul de la somme des termes d'une suite arithm\u00e9tique On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique : \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] Par exemple : \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta . On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\) . Rappel sur les complexit\u00e9s Voici un rappel sur les diff\u00e9rentes complexit\u00e9s : Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , on ne rajoute qu' une seule op\u00e9ration). Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 2 ). Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire. Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2 , le temps d'ex\u00e9cution est multipli\u00e9 par 4 ). Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100 , le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\) , soit 1267650600228229401496703205376 ). Source : https://buzut.net/cours/computer-science/time-complexity \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py . Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection , en utilisant une variable globale CNT incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e. Vous pouvez modifier l'instruction \u00e0 la ligne 38 en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons.","title":"Co\u00fbt du tri par s\u00e9lection"},{"location":"tri_selection_correction/#terminaison-du-tri-par-selection","text":"Variant de boucle On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que : \\(v\\) ne prend que des valeurs enti\u00e8res , \\(v\\) est initialement positive , \\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle. On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine , en un temps fini. S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a. Exemple D\u00e9montrons que la boucle for suivante se termine : POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5: Instructions ne modifiant pas la valeur de i... On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE : i = 10 TANT QUE i < 50: Instructions ne modifiant pas la valeur de i... i = i + 5 Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\) , avec \\(i_0\\) la valeur initiale de \\(i\\) et \\(r\\) la raison de la suite. Ici, \\(i_0 = 10\\) et \\(r = 5\\) . Donc \\(i_n = 10 + 5n\\) . On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante : TANT QUE \\(i_n < 50\\) TANT QUE \\(10 + 5n < 50\\) TANT QUE \\(0 < 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n > 0\\) TANT QUE \\(60 - 5n > 0\\) On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = 5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit bien d'une quantit\u00e9 enti\u00e8re , initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle. On a trouv\u00e9 un variant , et donc d\u00e9montr\u00e9 la terminaison de notre boucle . Question 1 Montrer la terminaison de l'algorithme de recherche du minimum . Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Question 2 Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection . Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME","title":"Terminaison du tri par s\u00e9lection"},{"location":"tri_selection_correction/#preuve-de-correction-du-tri-par-selection","text":"Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 : Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique , c'est-\u00e0-dire en \\(\\Theta(n^2)\\) . Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4 . La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer. Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct . Attention Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct , seulement qu'il fonctionne avec un jeu de tests d\u00e9fini. Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests. La preuve de correction d'un algorithme permet d'affirmer : qu'il fournit toujours la bonne r\u00e9ponse sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions ). Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme. Invariant de boucle On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle. L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu. Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant . Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne. Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence . D\u00e9monstration de l'invariant par r\u00e9currence Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\) , avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es : Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\) , c'est-\u00e0-dire avant le premier passage dans la boucle . Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle , et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\) , c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus . On peut \u00e9crire \\(P_k \\implies P_{k+1}\\) . Terminaison : \u00ab par r\u00e9currence, la proposition est vraie pour tout entier \\(k \\ge 0\\) . \u00bb Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en : un sous-tableau tri\u00e9 \u00e0 gauche, un sous-tableau non-tri\u00e9 \u00e0 droite. \u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9 . Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle. Une proposition d'invariant On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche . \u00bb Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Question 1 : Initialisation Apr\u00e8s 0 tour de boucle , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ? La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ? R\u00e9ponse 1 Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche . \u00bb Un tableau vide est bien tri\u00e9 , l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\) . On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\) , c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle. Question 2 Quelle valeur va prendre debut lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir tableau[debut] apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ? Quelle valeur va prendre debut lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ? \u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et debut . R\u00e9ponse 2 Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, debut vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). tableau[0] contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\) , on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1. k debut nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 etc. La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\) . On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose : d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\) d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\) D\u00e9montrons maintenant la conservation . Question 3 : Conservation Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie . R\u00e9ponse 3 D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale . \u00c0 la fin de l'it\u00e9ration \\(k\\) , nous avons : \\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\) une variable debut contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\) . On suppose que \\(P_k\\) est vraie , c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9 . Si l'on refait un tour de boucle, on incr\u00e9mente debut (car boucle POUR ). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\) On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l' \u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction minimum ) \u00e0 placer \u00e0 l'indice \\(k\\) . FINALEMENT , \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle : Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement). L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\) , autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9. Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s. La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e. Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que : dans la phase d' initialisation , on a montr\u00e9 que l' invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale , avec la conservation , on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\) , donc que l' invariant restait vrai apr\u00e8s chaque tour de boucle . On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que : \u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\) , debut vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9 , \u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\) , debut vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s , \u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\) , debut vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s , et ainsi de suite... DONC , \u00e0 la fin de la boucle POUR debut ALLANT DE 0 \u00c0 n - 2 , debut vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\) Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s . Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s , alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9 , puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal ) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 . Il est donc d\u00e9j\u00e0 \u00e0 la bonne position . On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection .","title":"Preuve de correction du tri par s\u00e9lection"}]}
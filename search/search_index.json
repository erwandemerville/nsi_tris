{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tri par s\u00e9lection et par insertion Bienvenue, ce site se d\u00e9compose en plusieurs parties : COURS : Activit\u00e9 pr\u00e9liminaire sur les tris Cours tri par s\u00e9lection Cours tri par insertion (\u00e0 venir) PYTHON : Impl\u00e9mentation tri par insertion (\u00e0 venir)","title":"Tri par s\u00e9lection et par insertion"},{"location":"#tri-par-selection-et-par-insertion","text":"Bienvenue, ce site se d\u00e9compose en plusieurs parties : COURS : Activit\u00e9 pr\u00e9liminaire sur les tris Cours tri par s\u00e9lection Cours tri par insertion (\u00e0 venir) PYTHON : Impl\u00e9mentation tri par insertion (\u00e0 venir)","title":"Tri par s\u00e9lection et par insertion"},{"location":"activite_preliminaire/","text":"Activit\u00e9 pr\u00e9liminaire sur les tris L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus. On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes. Partie 1 : Exp\u00e9rimentation La zone de jeu est constitu\u00e9e : d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7 , d'une zone temporaire dans laquelle on peut stocker l' indice ou la valeur d'une carte. Zone de jeu \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : Disposer une suite de 8 cartes arbitrairement choisies sur votre table. \u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes . Vous l'\u00e9crirez sur https://collab.infoforall.fr/ . Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'il fonctionne toujours. Important Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes : comparer les valeurs de deux cartes , permuter (\u00e9changer) deux cartes , copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement), vous pouvez utiliser des conditions ( SI ... , SINON ) et des boucles ( TANT QUE , POUR ... ALLANT DE ... A ... ). Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter : vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re), si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal), votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel. Partie 2 : Bilan des strat\u00e9gies Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes . \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement . Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas. Partie 3 : Tri par s\u00e9lection Principe du tri par s\u00e9lection Le tri par s\u00e9lection se d\u00e9roule comme suit : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la liste. Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite ) ayant cette valeur. \u00c0 faire 1 D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement. On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine , c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite. Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine , la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations , des comparaisons et des conditions . Recherche de la plus faible carte Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 : Stocker l' indice \\(i\\) dans la zone temporaire . En parcourant la suite de cartes de gauche \u00e0 droite , \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite : Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire . SI une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire , remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l' indice de cette carte . Renvoyer enfin l' indice contenu dans la zone temporaire . \u00c0 faire 2 Vous devez \u00e0 pr\u00e9sent : D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection , en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies. Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es. Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?","title":"Activit\u00e9 pr\u00e9liminaire"},{"location":"activite_preliminaire/#activite-preliminaire-sur-les-tris","text":"L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus. On ne se souciera ici que des valeurs des cartes et non de leurs couleurs . Voici l' ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte , que l'on utilisera : Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.","title":"Activit\u00e9 pr\u00e9liminaire sur les tris"},{"location":"activite_preliminaire/#partie-1-experimentation","text":"La zone de jeu est constitu\u00e9e : d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7 , d'une zone temporaire dans laquelle on peut stocker l' indice ou la valeur d'une carte. Zone de jeu \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : Disposer une suite de 8 cartes arbitrairement choisies sur votre table. \u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes . Vous l'\u00e9crirez sur https://collab.infoforall.fr/ . Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'il fonctionne toujours. Important Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes : comparer les valeurs de deux cartes , permuter (\u00e9changer) deux cartes , copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement), vous pouvez utiliser des conditions ( SI ... , SINON ) et des boucles ( TANT QUE , POUR ... ALLANT DE ... A ... ). Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter : vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re), si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal), votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel.","title":"Partie 1 : Exp\u00e9rimentation"},{"location":"activite_preliminaire/#partie-2-bilan-des-strategies","text":"Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes . \u00c0 faire Par groupes de 2 \u00e0 3 personnes, vous devez : D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement . Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas.","title":"Partie 2 : Bilan des strat\u00e9gies"},{"location":"activite_preliminaire/#partie-3-tri-par-selection","text":"Principe du tri par s\u00e9lection Le tri par s\u00e9lection se d\u00e9roule comme suit : Chercher l' indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier . La premi\u00e8re carte est maintenant la plus faible . Chercher l' indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1 ) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me . Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es . Poursuivre ainsi jusqu\u2019\u00e0 l\u2019 avant derni\u00e8re carte de la liste. Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite ) ayant cette valeur. \u00c0 faire 1 D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement. On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine , c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite. Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine , la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations , des comparaisons et des conditions . Recherche de la plus faible carte Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 : Stocker l' indice \\(i\\) dans la zone temporaire . En parcourant la suite de cartes de gauche \u00e0 droite , \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite : Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire . SI une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l' indice est stock\u00e9 dans la zone temporaire , remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l' indice de cette carte . Renvoyer enfin l' indice contenu dans la zone temporaire . \u00c0 faire 2 Vous devez \u00e0 pr\u00e9sent : D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection , en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies. Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es. Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?","title":"Partie 3 : Tri par s\u00e9lection"},{"location":"exercices_tri_selection/","text":"Exercices sur le tri par s\u00e9lection ...","title":"Exercices sur le tri par s\u00e9lection"},{"location":"exercices_tri_selection/#exercices-sur-le-tri-par-selection","text":"...","title":"Exercices sur le tri par s\u00e9lection"},{"location":"implementation_abr/","text":"Impl\u00e9mentation d'un arbre binaire de recherche L'impl\u00e9mentation d'un arbre binaire de recherche peut se faire de la m\u00eame fa\u00e7on que celle d'un arbre binaire classique. On va ici r\u00e9utiliser notre classe Arbre cr\u00e9\u00e9e lors de l'activit\u00e9 pr\u00e9c\u00e9dente . Cette activit\u00e9 sera divis\u00e9e en deux parties, qui consisteront \u00e0 : \u00e9crire des m\u00e9thodes permettant de v\u00e9rifier si un arbre binaire est un arbre binaire de recherche , \u00e9crire une m\u00e9thode de recherche et d' insertion dans un arbre binaire de recherche . Note : Par la suite, pour simplifier la r\u00e9daction, on utilisera parfois le terme \"arbre\" pour d\u00e9signer un arbre binaire. Op\u00e9rations de base En plus des op\u00e9rations \\(est\\_vide\\) , \\(est\\_feuille\\) , \\(gauche\\) , \\(droite\\) , \\(racine\\) , \\(valeur\\_racine\\) et \\(parcours\\_infixe\\) d\u00e9j\u00e0 vues, on d\u00e9finit ici de nouvelles op\u00e9rations . Trois op\u00e9rations visant \u00e0 v\u00e9rifier si l' arbre binaire est un arbre binaire de recherche : \\(maximum : Arbre \\rightarrow Int\\) : Renvoie la valeur maximale parmi les valeurs des noeuds d'un arbre binaire NON vide . \\(minimum : Arbre \\rightarrow Int\\) : Renvoie la valeur minimale parmi les valeurs des noeuds d'un arbre binaire NON vide . \\(est\\_ABR :~Arbre \\rightarrow Bool\\) : Renvoie True si un arbre binaire est un arbre binaire de recherche , False sinon. Dans le cas o\u00f9 l'arbre binaire est un arbre binaire de recherche , les op\u00e9rations de recherche et d' insertion sont ainsi d\u00e9finies : \\(rechercher :~Arbre \\times Element \\rightarrow Bool\\) : Renvoie True s'il existe un noeud de l'arbre binaire de recherche contenant la valeur donn\u00e9e , False sinon. \\(inserer :~Arbre \\times Element \\rightarrow Arbre\\) : Ins\u00e8re un nouveau noeud de valeur donn\u00e9e \u00e0 sa bonne position dans l'arbre binaire de recherche . Pour cette activit\u00e9, on \u00e9crira toutes les op\u00e9rations sous la forme de m\u00e9thodes . Rappel concernant la cr\u00e9ation et l'appel de m\u00e9thodes Une m\u00e9thode est une fonction d\u00e9finie \u00e0 l'int\u00e9rieur d'une classe . Elle prend toujours un param\u00e8tre self , puis \u00e9ventuellement d'autres param\u00e8tres : class Arbre : def __init__ ( self , valeur_racine = None , gauche = None , droite = None ): # Une m\u00e9thode sp\u00e9ciale : le constructeur de la classe ... def gauche ( self : 'Arbre' ) -> 'Arbre' : # Renvoie le sous-arbre gauche de l'arbre ... def droite ( self : 'Arbre' ) -> 'Arbre' : # Renvoie le sous-arbre droit de l'arbre ... def est_vide ( self : 'Arbre' ) -> bool : # Renvoie True si l'arbre est vide, False sinon ... def est_present ( self : 'Arbre' , val : 'int|str' ) -> bool : # Renvoie True s'il existe un noeud de valeur val dans l'arbre, False sinon ... Lors de l' appel \u00e0 une m\u00e9thode , on ne donne pas d'argument pour le param\u00e8tre self car il correspond \u00e0 l' adresse de l'objet sur lequel elle est appel\u00e9e . Si l'on souhaite par exemple savoir si le sous-arbre gauche d'un arbre binaire dont l'adresse est stock\u00e9e dans une variable ab est vide , il faudra \u00e9crire : ab . gauche () . est_vide () Si l'on souhaite maintenant savoir si le sous-arbre droit d'un arbre binaire dont l'adresse est stock\u00e9e dans une variable ab contient un noeud de valeur 42 , il faudra \u00e9crire : ab . droite () . est_present ( 42 ) \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rez le fichier suivant : abr.py - Classe Arbre \u00e0 compl\u00e9ter repr\u00e9sentant un arbre binaire avec les nouvelles m\u00e9thodes relatives aux arbres binaires de recherche . Si vous souhaitez utiliser les fonctions de dessin avec Graphviz Ce n'est pas obligatoire, mais si vous souhaitez, comme pour l'activit\u00e9 pr\u00e9c\u00e9dente, pouvoir afficher un dessin de votre arbre, les fichiers \u00e0 avoir sur votre machine sont toujours les m\u00eames : dessin.py - Quelques fonctions annexes utilis\u00e9es pour dessiner un arbre avec le module Graphviz . (Vous n'avez pas besoin d'ouvrir ou de modifier ce fichier.) Si vous utilisez les machines du lyc\u00e9e (sinon, voir cette page pour la proc\u00e9dure pour installer Graphviz chez vous) : windows_graphviz.zip - D\u00e9compressez l'archive dans le r\u00e9pertoire o\u00f9 se trouvent vos fichiers Python . Vous devez avoir abr.py , dessin.py et un dossier Graphviz au m\u00eame endroit. Contient les ex\u00e9cutables de Graphviz . Pour utiliser les fonctions de dessin.py , vous devez \u00e9galement d\u00e9-commenter la premi\u00e8re ligne from dessin import dessiner du fichier abr.py , qui a \u00e9t\u00e9 comment\u00e9e pour \u00e9viter les erreurs. Corrig\u00e9 complet Cliquez ici pour t\u00e9l\u00e9charger le corrig\u00e9 complet de cette activit\u00e9. Important Ici, on a fait le choix de travailler avec une structure immuable . En l'occurence, la m\u00e9thode inserer renvoie un nouvel arbre binaire de recherche , et ne modifie pas directement l'arbre sur lequel elle est appel\u00e9e. Tester son programme avec le module doctest Plusieurs tests ont \u00e9t\u00e9 r\u00e9dig\u00e9s dans la docstring du constructeur de la classe. Rien ne vous emp\u00eache de rajouter davantage de tests si vous le souhaitez. Pour tester votre programme, vous avez simplement \u00e0 ex\u00e9cuter celui-ci , et s'il n'y a pas d'erreurs, il ne se passera rien . S'il y a des erreurs, vous obtiendrez des d\u00e9tails sur les tests qui n'ont pas fonctionn\u00e9. Pour activer le mode \"verbeux\" et obtenir encore plus de d\u00e9tails sur les erreurs, vous pouvez passer le param\u00e8tre verbose \u00e0 True (sur la toute derni\u00e8re ligne du programme). Maximum et minimum Pour pouvoir \u00e9crire une m\u00e9thode permettant de d\u00e9finir si un arbre binaire est un arbre binaire de recherche , on se propose d'abord d'\u00e9crire deux m\u00e9thodes permettant de d\u00e9terminer la valeur minimale et la valeur maximale des noeuds d'un arbre binaire de mani\u00e8re g\u00e9n\u00e9rale. Ces deux fonctions : ne sont d\u00e9finies que pour des arbres binaires non vides , comme indiqu\u00e9 dans les CU ( C onditions d' U tilisation) de la fonction, n\u00e9cessitent d'identifier un cas de base et plusieurs cas r\u00e9cursifs . Vous pourrez utiliser les fonctions min et max de Python , qui renvoient respectivement le minimum et le maximum parmi plusieurs \u00e9l\u00e9ments, ou parmi les \u00e9l\u00e9ments d'une liste/d'un tuple. Exercice 1 \u00c9crire le code Python des m\u00e9thodes minimum et maximum . Aide - Exercice 1 Vous pouvez distinguer les 4 cas suivants : Le cas o\u00f9 l'arbre donn\u00e9 est une feuille (= sous-arbres gauche et droit vides ), qui est le cas de base Le cas o\u00f9 le sous-arbre gauche uniquement est vide Le cas o\u00f9 le sous-arbre droit uniquement est vide Le cas o\u00f9 les deux sous-arbres sont NON vides Encore plus d'aide - Exercice 1 Voici une partie du code, \u00e0 compl\u00e9ter . def minimum ( self : 'Arbre' ) -> int : ''' Renvoie la valeur minimale des noeuds de l'arbre :CU: L'arbre n'est PAS vide ''' if self . est_feuille (): ... elif self . gauche () . est_vide (): return min ( self . valeur_racine (), self . droite () . minimum ()) elif self . droite () . est_vide (): ... else : ... Solution - Exercice 1 def minimum ( self : 'Arbre' ) -> int : ''' Renvoie la valeur minimale des noeuds de l'arbre :CU: L'abre n'est PAS vide ''' if self . est_feuille (): return self . valeur_racine () elif self . gauche () . est_vide (): return min ( self . valeur_racine (), self . droite () . minimum ()) elif self . droite () . est_vide (): return min ( self . valeur_racine (), self . gauche () . minimum ()) else : return min ( self . gauche () . minimum (), self . valeur_racine (), self . droite () . minimum ()) def maximum ( self : 'Arbre' ) -> int : ''' Renvoie la valeur maximale des noeuds de l'arbre :CU: L'arbre n'est PAS vide ''' if self . est_feuille (): return self . valeur_racine () elif self . gauche () . est_vide (): return max ( self . valeur_racine (), self . droite () . maximum ()) elif self . droite () . est_vide (): return max ( self . valeur_racine (), self . gauche () . maximum ()) else : return max ( self . gauche () . maximum (), self . valeur_racine (), self . droite () . maximum ()) La m\u00e9thode est_abr On peut maintenant \u00e9crire une m\u00e9thode qui permet de v\u00e9rifier qu'un arbre binaire cr\u00e9\u00e9 avec la classe Arbre soit un arbre binaire de recherche . Un arbre binaire est un arbre binaire de recherche si : l' arbre est vide ou est une feuille , OU BIEN si le sous-arbre gauche n'est pas vide , les \u00e9l\u00e9ments des noeuds du sous-arbre gauche sont tous \\(\\leq\\) \u00e0 l' \u00e9l\u00e9ment de la racine , ET si le sous-arbre droit n'est pas vide , les \u00e9l\u00e9ments des noeuds du sous-arbre droit sont tous \\(>\\) \u00e0 l' \u00e9l\u00e9ment de la racine , ET les sous-arbres gauches et droit sont \u00e9galement des arbres binaires de recherche . La fonction est_abr renvoie donc False si l' une de ces conditions n'est pas remplie , et renvoie True sinon. Exercice 2 \u00c9crire le code Python de la m\u00e9thode est_abr . Aide - Exercice 2 Le cas o\u00f9 l' arbre est vide ou l' arbre est une feuille est le cas de base , non r\u00e9cursif. Dans ce cas-l\u00e0, on consid\u00e8re que l'arbre est un arbre binaire de recherche . On renverra donc True si l'on se trouve dans l'un de ces deux cas. Il ne reste plus qu'\u00e0 v\u00e9rifier les trois autres conditions \u00e9voqu\u00e9es pr\u00e9c\u00e9demment. Une solution est de v\u00e9rifier , pour chaque condition , si elle n' est pas remplie , et de renvoyer False le cas \u00e9ch\u00e9ant. Une fois que les trois conditions ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, on renvoie donc True . Encore plus d'aide - Exercice 2 Voici une partie du code, \u00e0 compl\u00e9ter . def est_ABR ( self : 'Arbre' ) -> bool : ''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. ''' if self . est_vide () or self . est_feuille (): return ... else : if not self . gauche () . est_vide () and self . gauche () . maximum () > self . valeur_racine (): return ... if ... and ... : return ... if ... or ... : return ... return ... Solution - Exercice 2 def est_ABR ( self : 'Arbre' ) -> bool : ''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. ''' if self . est_vide () or self . est_feuille (): return True else : if not self . gauche () . est_vide () and self . gauche () . maximum () > self . valeur_racine (): return False if not self . droite () . est_vide () and self . droite () . minimum () <= self . valeur_racine (): return False if not self . gauche () . est_ABR () or not self . droite () . est_ABR (): return False return True Une autre solution plus simple pour v\u00e9rifier si un arbre binaire est un arbre binaire de recherche est de v\u00e9rifier si la liste des valeurs des noeuds visit\u00e9s en ordre infixe est tri\u00e9e . Exercice 3 Compl\u00e9tez le corps de la m\u00e9thode est_ABR_v2 . Aide - Exercice 3 Il suffit simplement de v\u00e9rifier que la liste lst_valeurs soit tri\u00e9e en la parcourant et en v\u00e9rifiant que chaque \u00e9l\u00e9ment soit sup\u00e9rieur \u00e0 l' \u00e9l\u00e9ment qui le pr\u00e9c\u00e8de . Si l'on se rend compte qu'un \u00e9l\u00e9ment est inf\u00e9rieur \u00e0 son pr\u00e9decesseur, on renvoie False . Sinon, on renvoie True . Solution - Exercice 3 def est_ABR_v2 ( self : 'Arbre' ) -> bool : ''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. Autre version, v\u00e9rifiant si la liste des noeuds visit\u00e9s en ordre infixe est tri\u00e9e dans l'ordre croissant. ''' lst_valeurs = self . parcours_infixe () # R\u00e9cup\u00e9rer la liste des valeurs des noeuds visit\u00e9s en parcours infixe for i in range ( 1 , len ( lst_valeurs )): if lst_valeurs [ i ] < lst_valeurs [ i - 1 ]: return False return True Recherche dans un arbre binaire de recherche \u00c0 savoir pour le bac L'algorithme de recherche dans un arbre binaire de recherche fait partie des algorithmes \u00e0 ma\u00eetriser pour le baccalaur\u00e9at. Comme cela a \u00e9t\u00e9 vu dans les exercices , la rercherche dans un arbre binaire de recherche se d\u00e9roule de la mani\u00e8re suivante. D\u00e9roulement rechercher Pr\u00e9condition : l' arbre donn\u00e9 est un arbre binaire de recherche . L'algorithme rechercher se d\u00e9roule comme suit : Si l' arbre binaire est vide : on renvoie Faux . Sinon ( l'arbre binaire n'est pas vide ): Si la valeur de la racine de l'arbre est \u00e9gale \u00e0 l' \u00e9l\u00e9ment recherch\u00e9 : on renvoie Vrai . Sinon, si l' \u00e9l\u00e9ment recherch\u00e9 est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine de l'arbre , rechercher l'\u00e9l\u00e9ment dans le sous-arbre gauche . Sinon, on rechercher l'\u00e9l\u00e9ment dans le sous-arbre droit . Exercice 4 En vous aidant du d\u00e9roulement d\u00e9crit ci-dessus, \u00e9crire le code Python de la m\u00e9thode rechercher . Remarque : On aura pas besoin de rajouter une condition dans le code pour v\u00e9rifier si l'arbre binaire est bien un arbre binaire de recherche, car cela a \u00e9t\u00e9 sp\u00e9cifi\u00e9 en tant que condition d'utilisation ( CU ) : ''' :CU: self.est_ABR() == True ''' Solution - Exercice 4 def rechercher ( self : 'Arbre' , elt : 'int|str' ) -> bool : ''' Recherche l'\u00e9l\u00e9ment elt dans l'arbre, renvoie True s'il est trouv\u00e9, False sinon. :CU: self.est_ABR() == True ''' if self . est_vide (): return False elif self . valeur_racine () == elt : return True elif elt <= self . valeur_racine (): return self . gauche () . rechercher ( elt ) else : return self . droite () . rechercher ( elt ) Insertion dans un arbre binaire de recherche \u00c0 savoir pour le bac L'algorithme d' insertion dans un arbre binaire de recherche fait partie des algorithmes \u00e0 ma\u00eetriser pour le baccalaur\u00e9at. Enfin, l' insertion dans un arbre binaire de recherche est assez similaire \u00e0 la recherche . D\u00e9roulement inserer Pr\u00e9condition : l' arbre donn\u00e9 est un arbre binaire de recherche . L'algorithme inserer se d\u00e9roule comme suit : Si l' arbre binaire est vide : on renvoie une nouvelle feuille contenant l' \u00e9l\u00e9ment \u00e0 ins\u00e9rer . Sinon ( l'arbre binaire n'est pas vide ): Si l' \u00e9l\u00e9ment \u00e0 ins\u00e9rer est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine de l'arbre , inserer l'\u00e9l\u00e9ment dans le sous-arbre gauche . On renvoie l'arbre r\u00e9sultant de cette insertion. Sinon, inserer l'\u00e9l\u00e9ment dans le sous-arbre droit . On renvoie l'arbre r\u00e9sultant de cette insertion. Exercice 5 En vous aidant du d\u00e9roulement d\u00e9crit ci-dessus, \u00e9crire le code Python de la m\u00e9thode inserer . Attention , inserer doit toujours renvoyer un objet de type Arbre . Remarque : Ici \u00e9galement, on aura pas besoin de rajouter une condition dans le code pour v\u00e9rifier si l'arbre binaire est bien un arbre binaire de recherche. Solution - Exercice 5 def inserer ( self : 'Arbre' , elt : 'int|str' ) -> 'Arbre' : ''' Ins\u00e8re l'\u00e9l\u00e9ment elt dans l'arbre :CU: self.est_ABR() == True ''' if self . est_vide (): return Arbre ( elt , Arbre (), Arbre ()) else : if elt <= self . valeur_racine (): return Arbre ( self . valeur_racine (), self . gauche () . inserer ( elt ), self . droite ()) else : return Arbre ( self . valeur_racine (), self . gauche (), self . droite () . inserer ( elt )) Trier une liste avec un arbre binaire de recherche Exercice 6 Compl\u00e9ter la fonction trier qui prend une liste d'\u00e9l\u00e9ments et renvoie une nouvelle liste contenant les m\u00eames \u00e9l\u00e9ments, mais tri\u00e9s par ordre croissant . Vous devez pour cela utiliser un arbre binaire de recherche et la m\u00e9thode parcours_infixe . Attention : Il s'agit d'une fonction plac\u00e9e en dehors de la classe , et non pas d'une m\u00e9thode de Arbre . Aide - Exercice 6 Il suffit simplement de : cr\u00e9er un nouvel arbre binaire de recherche vide , de parcourir la liste \u00e0 trier en ins\u00e9rant chaque \u00e9l\u00e9ment dans l'arbre, puis d'appeler la fonction parcours_infixe sur l'arbre cr\u00e9\u00e9 pour obtenir la liste des valeurs des n\u0153uds tri\u00e9e dans l' ordre croissant . Si l'on souhaite cr\u00e9er un nouvel arbre binaire vide dans une variable abr , on devra donc \u00e9crire : abr = Arbre () Solution - Exercice 6 def trier ( liste : list ) -> list : ''' Trie les \u00e9l\u00e9ments (int|str) d'une liste dans l'ordre croissant. Renvoie la liste tri\u00e9e. ''' abr = Arbre () for el in liste : abr = abr . inserer ( el ) return abr . parcours_infixe () Aller plus loin : minimum et maximum d'un arbre binaire de recherche Pour trouver le plus petit \u00e9l\u00e9ment d'un arbre binaire de recherche , on proc\u00e8de comme suit : Si l'arbre n'a pas de sous-arbre gauche , son minimum est alors la valeur de sa racine . Sinon, il s'agit du minimum (r\u00e9cursivement) de son sous-arbre gauche . Pour le maximum , c'est le m\u00eame principe mais avec le sous-arbre droit . Exercice 7 Compl\u00e9tez les m\u00e9thodes minimum_abr et maximum_abr qui renvoient la valeur minimale et la valeur maximale des n\u0153uds de l'arbre dans le cas d'un arbre binaire de recherche . Solution - Exercice 7 def minimum_abr ( self : 'Arbre' ) -> int : ''' Renvoie la valeur minimale des noeuds de l'arbre binaire de recherche :CU: self.est_ABR() == True and not self.est_vide() ''' if self . gauche () . est_vide (): return self . valeur_racine () else : return self . gauche () . minimum_abr () def maximum_abr ( self : 'Arbre' ) -> int : ''' Renvoie la valeur maximale des noeuds de l'arbre binaire de recherche :CU: self.est_ABR() == True and not self.est_vide() ''' if self . droite () . est_vide (): return self . valeur_racine () else : return self . droite () . maximum_abr ()","title":"Impl\u00e9mentation d'un arbre binaire de recherche"},{"location":"implementation_abr/#implementation-dun-arbre-binaire-de-recherche","text":"L'impl\u00e9mentation d'un arbre binaire de recherche peut se faire de la m\u00eame fa\u00e7on que celle d'un arbre binaire classique. On va ici r\u00e9utiliser notre classe Arbre cr\u00e9\u00e9e lors de l'activit\u00e9 pr\u00e9c\u00e9dente . Cette activit\u00e9 sera divis\u00e9e en deux parties, qui consisteront \u00e0 : \u00e9crire des m\u00e9thodes permettant de v\u00e9rifier si un arbre binaire est un arbre binaire de recherche , \u00e9crire une m\u00e9thode de recherche et d' insertion dans un arbre binaire de recherche . Note : Par la suite, pour simplifier la r\u00e9daction, on utilisera parfois le terme \"arbre\" pour d\u00e9signer un arbre binaire. Op\u00e9rations de base En plus des op\u00e9rations \\(est\\_vide\\) , \\(est\\_feuille\\) , \\(gauche\\) , \\(droite\\) , \\(racine\\) , \\(valeur\\_racine\\) et \\(parcours\\_infixe\\) d\u00e9j\u00e0 vues, on d\u00e9finit ici de nouvelles op\u00e9rations . Trois op\u00e9rations visant \u00e0 v\u00e9rifier si l' arbre binaire est un arbre binaire de recherche : \\(maximum : Arbre \\rightarrow Int\\) : Renvoie la valeur maximale parmi les valeurs des noeuds d'un arbre binaire NON vide . \\(minimum : Arbre \\rightarrow Int\\) : Renvoie la valeur minimale parmi les valeurs des noeuds d'un arbre binaire NON vide . \\(est\\_ABR :~Arbre \\rightarrow Bool\\) : Renvoie True si un arbre binaire est un arbre binaire de recherche , False sinon. Dans le cas o\u00f9 l'arbre binaire est un arbre binaire de recherche , les op\u00e9rations de recherche et d' insertion sont ainsi d\u00e9finies : \\(rechercher :~Arbre \\times Element \\rightarrow Bool\\) : Renvoie True s'il existe un noeud de l'arbre binaire de recherche contenant la valeur donn\u00e9e , False sinon. \\(inserer :~Arbre \\times Element \\rightarrow Arbre\\) : Ins\u00e8re un nouveau noeud de valeur donn\u00e9e \u00e0 sa bonne position dans l'arbre binaire de recherche . Pour cette activit\u00e9, on \u00e9crira toutes les op\u00e9rations sous la forme de m\u00e9thodes . Rappel concernant la cr\u00e9ation et l'appel de m\u00e9thodes Une m\u00e9thode est une fonction d\u00e9finie \u00e0 l'int\u00e9rieur d'une classe . Elle prend toujours un param\u00e8tre self , puis \u00e9ventuellement d'autres param\u00e8tres : class Arbre : def __init__ ( self , valeur_racine = None , gauche = None , droite = None ): # Une m\u00e9thode sp\u00e9ciale : le constructeur de la classe ... def gauche ( self : 'Arbre' ) -> 'Arbre' : # Renvoie le sous-arbre gauche de l'arbre ... def droite ( self : 'Arbre' ) -> 'Arbre' : # Renvoie le sous-arbre droit de l'arbre ... def est_vide ( self : 'Arbre' ) -> bool : # Renvoie True si l'arbre est vide, False sinon ... def est_present ( self : 'Arbre' , val : 'int|str' ) -> bool : # Renvoie True s'il existe un noeud de valeur val dans l'arbre, False sinon ... Lors de l' appel \u00e0 une m\u00e9thode , on ne donne pas d'argument pour le param\u00e8tre self car il correspond \u00e0 l' adresse de l'objet sur lequel elle est appel\u00e9e . Si l'on souhaite par exemple savoir si le sous-arbre gauche d'un arbre binaire dont l'adresse est stock\u00e9e dans une variable ab est vide , il faudra \u00e9crire : ab . gauche () . est_vide () Si l'on souhaite maintenant savoir si le sous-arbre droit d'un arbre binaire dont l'adresse est stock\u00e9e dans une variable ab contient un noeud de valeur 42 , il faudra \u00e9crire : ab . droite () . est_present ( 42 ) \u00c0 t\u00e9l\u00e9charger R\u00e9cup\u00e9rez le fichier suivant : abr.py - Classe Arbre \u00e0 compl\u00e9ter repr\u00e9sentant un arbre binaire avec les nouvelles m\u00e9thodes relatives aux arbres binaires de recherche . Si vous souhaitez utiliser les fonctions de dessin avec Graphviz Ce n'est pas obligatoire, mais si vous souhaitez, comme pour l'activit\u00e9 pr\u00e9c\u00e9dente, pouvoir afficher un dessin de votre arbre, les fichiers \u00e0 avoir sur votre machine sont toujours les m\u00eames : dessin.py - Quelques fonctions annexes utilis\u00e9es pour dessiner un arbre avec le module Graphviz . (Vous n'avez pas besoin d'ouvrir ou de modifier ce fichier.) Si vous utilisez les machines du lyc\u00e9e (sinon, voir cette page pour la proc\u00e9dure pour installer Graphviz chez vous) : windows_graphviz.zip - D\u00e9compressez l'archive dans le r\u00e9pertoire o\u00f9 se trouvent vos fichiers Python . Vous devez avoir abr.py , dessin.py et un dossier Graphviz au m\u00eame endroit. Contient les ex\u00e9cutables de Graphviz . Pour utiliser les fonctions de dessin.py , vous devez \u00e9galement d\u00e9-commenter la premi\u00e8re ligne from dessin import dessiner du fichier abr.py , qui a \u00e9t\u00e9 comment\u00e9e pour \u00e9viter les erreurs. Corrig\u00e9 complet Cliquez ici pour t\u00e9l\u00e9charger le corrig\u00e9 complet de cette activit\u00e9. Important Ici, on a fait le choix de travailler avec une structure immuable . En l'occurence, la m\u00e9thode inserer renvoie un nouvel arbre binaire de recherche , et ne modifie pas directement l'arbre sur lequel elle est appel\u00e9e. Tester son programme avec le module doctest Plusieurs tests ont \u00e9t\u00e9 r\u00e9dig\u00e9s dans la docstring du constructeur de la classe. Rien ne vous emp\u00eache de rajouter davantage de tests si vous le souhaitez. Pour tester votre programme, vous avez simplement \u00e0 ex\u00e9cuter celui-ci , et s'il n'y a pas d'erreurs, il ne se passera rien . S'il y a des erreurs, vous obtiendrez des d\u00e9tails sur les tests qui n'ont pas fonctionn\u00e9. Pour activer le mode \"verbeux\" et obtenir encore plus de d\u00e9tails sur les erreurs, vous pouvez passer le param\u00e8tre verbose \u00e0 True (sur la toute derni\u00e8re ligne du programme).","title":"Impl\u00e9mentation d'un arbre binaire de recherche"},{"location":"implementation_abr/#maximum-et-minimum","text":"Pour pouvoir \u00e9crire une m\u00e9thode permettant de d\u00e9finir si un arbre binaire est un arbre binaire de recherche , on se propose d'abord d'\u00e9crire deux m\u00e9thodes permettant de d\u00e9terminer la valeur minimale et la valeur maximale des noeuds d'un arbre binaire de mani\u00e8re g\u00e9n\u00e9rale. Ces deux fonctions : ne sont d\u00e9finies que pour des arbres binaires non vides , comme indiqu\u00e9 dans les CU ( C onditions d' U tilisation) de la fonction, n\u00e9cessitent d'identifier un cas de base et plusieurs cas r\u00e9cursifs . Vous pourrez utiliser les fonctions min et max de Python , qui renvoient respectivement le minimum et le maximum parmi plusieurs \u00e9l\u00e9ments, ou parmi les \u00e9l\u00e9ments d'une liste/d'un tuple. Exercice 1 \u00c9crire le code Python des m\u00e9thodes minimum et maximum . Aide - Exercice 1 Vous pouvez distinguer les 4 cas suivants : Le cas o\u00f9 l'arbre donn\u00e9 est une feuille (= sous-arbres gauche et droit vides ), qui est le cas de base Le cas o\u00f9 le sous-arbre gauche uniquement est vide Le cas o\u00f9 le sous-arbre droit uniquement est vide Le cas o\u00f9 les deux sous-arbres sont NON vides Encore plus d'aide - Exercice 1 Voici une partie du code, \u00e0 compl\u00e9ter . def minimum ( self : 'Arbre' ) -> int : ''' Renvoie la valeur minimale des noeuds de l'arbre :CU: L'arbre n'est PAS vide ''' if self . est_feuille (): ... elif self . gauche () . est_vide (): return min ( self . valeur_racine (), self . droite () . minimum ()) elif self . droite () . est_vide (): ... else : ... Solution - Exercice 1 def minimum ( self : 'Arbre' ) -> int : ''' Renvoie la valeur minimale des noeuds de l'arbre :CU: L'abre n'est PAS vide ''' if self . est_feuille (): return self . valeur_racine () elif self . gauche () . est_vide (): return min ( self . valeur_racine (), self . droite () . minimum ()) elif self . droite () . est_vide (): return min ( self . valeur_racine (), self . gauche () . minimum ()) else : return min ( self . gauche () . minimum (), self . valeur_racine (), self . droite () . minimum ()) def maximum ( self : 'Arbre' ) -> int : ''' Renvoie la valeur maximale des noeuds de l'arbre :CU: L'arbre n'est PAS vide ''' if self . est_feuille (): return self . valeur_racine () elif self . gauche () . est_vide (): return max ( self . valeur_racine (), self . droite () . maximum ()) elif self . droite () . est_vide (): return max ( self . valeur_racine (), self . gauche () . maximum ()) else : return max ( self . gauche () . maximum (), self . valeur_racine (), self . droite () . maximum ())","title":"Maximum et minimum"},{"location":"implementation_abr/#la-methode-est_abr","text":"On peut maintenant \u00e9crire une m\u00e9thode qui permet de v\u00e9rifier qu'un arbre binaire cr\u00e9\u00e9 avec la classe Arbre soit un arbre binaire de recherche . Un arbre binaire est un arbre binaire de recherche si : l' arbre est vide ou est une feuille , OU BIEN si le sous-arbre gauche n'est pas vide , les \u00e9l\u00e9ments des noeuds du sous-arbre gauche sont tous \\(\\leq\\) \u00e0 l' \u00e9l\u00e9ment de la racine , ET si le sous-arbre droit n'est pas vide , les \u00e9l\u00e9ments des noeuds du sous-arbre droit sont tous \\(>\\) \u00e0 l' \u00e9l\u00e9ment de la racine , ET les sous-arbres gauches et droit sont \u00e9galement des arbres binaires de recherche . La fonction est_abr renvoie donc False si l' une de ces conditions n'est pas remplie , et renvoie True sinon. Exercice 2 \u00c9crire le code Python de la m\u00e9thode est_abr . Aide - Exercice 2 Le cas o\u00f9 l' arbre est vide ou l' arbre est une feuille est le cas de base , non r\u00e9cursif. Dans ce cas-l\u00e0, on consid\u00e8re que l'arbre est un arbre binaire de recherche . On renverra donc True si l'on se trouve dans l'un de ces deux cas. Il ne reste plus qu'\u00e0 v\u00e9rifier les trois autres conditions \u00e9voqu\u00e9es pr\u00e9c\u00e9demment. Une solution est de v\u00e9rifier , pour chaque condition , si elle n' est pas remplie , et de renvoyer False le cas \u00e9ch\u00e9ant. Une fois que les trois conditions ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, on renvoie donc True . Encore plus d'aide - Exercice 2 Voici une partie du code, \u00e0 compl\u00e9ter . def est_ABR ( self : 'Arbre' ) -> bool : ''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. ''' if self . est_vide () or self . est_feuille (): return ... else : if not self . gauche () . est_vide () and self . gauche () . maximum () > self . valeur_racine (): return ... if ... and ... : return ... if ... or ... : return ... return ... Solution - Exercice 2 def est_ABR ( self : 'Arbre' ) -> bool : ''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. ''' if self . est_vide () or self . est_feuille (): return True else : if not self . gauche () . est_vide () and self . gauche () . maximum () > self . valeur_racine (): return False if not self . droite () . est_vide () and self . droite () . minimum () <= self . valeur_racine (): return False if not self . gauche () . est_ABR () or not self . droite () . est_ABR (): return False return True Une autre solution plus simple pour v\u00e9rifier si un arbre binaire est un arbre binaire de recherche est de v\u00e9rifier si la liste des valeurs des noeuds visit\u00e9s en ordre infixe est tri\u00e9e . Exercice 3 Compl\u00e9tez le corps de la m\u00e9thode est_ABR_v2 . Aide - Exercice 3 Il suffit simplement de v\u00e9rifier que la liste lst_valeurs soit tri\u00e9e en la parcourant et en v\u00e9rifiant que chaque \u00e9l\u00e9ment soit sup\u00e9rieur \u00e0 l' \u00e9l\u00e9ment qui le pr\u00e9c\u00e8de . Si l'on se rend compte qu'un \u00e9l\u00e9ment est inf\u00e9rieur \u00e0 son pr\u00e9decesseur, on renvoie False . Sinon, on renvoie True . Solution - Exercice 3 def est_ABR_v2 ( self : 'Arbre' ) -> bool : ''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. Autre version, v\u00e9rifiant si la liste des noeuds visit\u00e9s en ordre infixe est tri\u00e9e dans l'ordre croissant. ''' lst_valeurs = self . parcours_infixe () # R\u00e9cup\u00e9rer la liste des valeurs des noeuds visit\u00e9s en parcours infixe for i in range ( 1 , len ( lst_valeurs )): if lst_valeurs [ i ] < lst_valeurs [ i - 1 ]: return False return True","title":"La m\u00e9thode est_abr"},{"location":"implementation_abr/#recherche-dans-un-arbre-binaire-de-recherche","text":"\u00c0 savoir pour le bac L'algorithme de recherche dans un arbre binaire de recherche fait partie des algorithmes \u00e0 ma\u00eetriser pour le baccalaur\u00e9at. Comme cela a \u00e9t\u00e9 vu dans les exercices , la rercherche dans un arbre binaire de recherche se d\u00e9roule de la mani\u00e8re suivante. D\u00e9roulement rechercher Pr\u00e9condition : l' arbre donn\u00e9 est un arbre binaire de recherche . L'algorithme rechercher se d\u00e9roule comme suit : Si l' arbre binaire est vide : on renvoie Faux . Sinon ( l'arbre binaire n'est pas vide ): Si la valeur de la racine de l'arbre est \u00e9gale \u00e0 l' \u00e9l\u00e9ment recherch\u00e9 : on renvoie Vrai . Sinon, si l' \u00e9l\u00e9ment recherch\u00e9 est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine de l'arbre , rechercher l'\u00e9l\u00e9ment dans le sous-arbre gauche . Sinon, on rechercher l'\u00e9l\u00e9ment dans le sous-arbre droit . Exercice 4 En vous aidant du d\u00e9roulement d\u00e9crit ci-dessus, \u00e9crire le code Python de la m\u00e9thode rechercher . Remarque : On aura pas besoin de rajouter une condition dans le code pour v\u00e9rifier si l'arbre binaire est bien un arbre binaire de recherche, car cela a \u00e9t\u00e9 sp\u00e9cifi\u00e9 en tant que condition d'utilisation ( CU ) : ''' :CU: self.est_ABR() == True ''' Solution - Exercice 4 def rechercher ( self : 'Arbre' , elt : 'int|str' ) -> bool : ''' Recherche l'\u00e9l\u00e9ment elt dans l'arbre, renvoie True s'il est trouv\u00e9, False sinon. :CU: self.est_ABR() == True ''' if self . est_vide (): return False elif self . valeur_racine () == elt : return True elif elt <= self . valeur_racine (): return self . gauche () . rechercher ( elt ) else : return self . droite () . rechercher ( elt )","title":"Recherche dans un arbre binaire de recherche"},{"location":"implementation_abr/#insertion-dans-un-arbre-binaire-de-recherche","text":"\u00c0 savoir pour le bac L'algorithme d' insertion dans un arbre binaire de recherche fait partie des algorithmes \u00e0 ma\u00eetriser pour le baccalaur\u00e9at. Enfin, l' insertion dans un arbre binaire de recherche est assez similaire \u00e0 la recherche . D\u00e9roulement inserer Pr\u00e9condition : l' arbre donn\u00e9 est un arbre binaire de recherche . L'algorithme inserer se d\u00e9roule comme suit : Si l' arbre binaire est vide : on renvoie une nouvelle feuille contenant l' \u00e9l\u00e9ment \u00e0 ins\u00e9rer . Sinon ( l'arbre binaire n'est pas vide ): Si l' \u00e9l\u00e9ment \u00e0 ins\u00e9rer est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine de l'arbre , inserer l'\u00e9l\u00e9ment dans le sous-arbre gauche . On renvoie l'arbre r\u00e9sultant de cette insertion. Sinon, inserer l'\u00e9l\u00e9ment dans le sous-arbre droit . On renvoie l'arbre r\u00e9sultant de cette insertion. Exercice 5 En vous aidant du d\u00e9roulement d\u00e9crit ci-dessus, \u00e9crire le code Python de la m\u00e9thode inserer . Attention , inserer doit toujours renvoyer un objet de type Arbre . Remarque : Ici \u00e9galement, on aura pas besoin de rajouter une condition dans le code pour v\u00e9rifier si l'arbre binaire est bien un arbre binaire de recherche. Solution - Exercice 5 def inserer ( self : 'Arbre' , elt : 'int|str' ) -> 'Arbre' : ''' Ins\u00e8re l'\u00e9l\u00e9ment elt dans l'arbre :CU: self.est_ABR() == True ''' if self . est_vide (): return Arbre ( elt , Arbre (), Arbre ()) else : if elt <= self . valeur_racine (): return Arbre ( self . valeur_racine (), self . gauche () . inserer ( elt ), self . droite ()) else : return Arbre ( self . valeur_racine (), self . gauche (), self . droite () . inserer ( elt ))","title":"Insertion dans un arbre binaire de recherche"},{"location":"implementation_abr/#trier-une-liste-avec-un-arbre-binaire-de-recherche","text":"Exercice 6 Compl\u00e9ter la fonction trier qui prend une liste d'\u00e9l\u00e9ments et renvoie une nouvelle liste contenant les m\u00eames \u00e9l\u00e9ments, mais tri\u00e9s par ordre croissant . Vous devez pour cela utiliser un arbre binaire de recherche et la m\u00e9thode parcours_infixe . Attention : Il s'agit d'une fonction plac\u00e9e en dehors de la classe , et non pas d'une m\u00e9thode de Arbre . Aide - Exercice 6 Il suffit simplement de : cr\u00e9er un nouvel arbre binaire de recherche vide , de parcourir la liste \u00e0 trier en ins\u00e9rant chaque \u00e9l\u00e9ment dans l'arbre, puis d'appeler la fonction parcours_infixe sur l'arbre cr\u00e9\u00e9 pour obtenir la liste des valeurs des n\u0153uds tri\u00e9e dans l' ordre croissant . Si l'on souhaite cr\u00e9er un nouvel arbre binaire vide dans une variable abr , on devra donc \u00e9crire : abr = Arbre () Solution - Exercice 6 def trier ( liste : list ) -> list : ''' Trie les \u00e9l\u00e9ments (int|str) d'une liste dans l'ordre croissant. Renvoie la liste tri\u00e9e. ''' abr = Arbre () for el in liste : abr = abr . inserer ( el ) return abr . parcours_infixe ()","title":"Trier une liste avec un arbre binaire de recherche"},{"location":"implementation_abr/#aller-plus-loin-minimum-et-maximum-dun-arbre-binaire-de-recherche","text":"Pour trouver le plus petit \u00e9l\u00e9ment d'un arbre binaire de recherche , on proc\u00e8de comme suit : Si l'arbre n'a pas de sous-arbre gauche , son minimum est alors la valeur de sa racine . Sinon, il s'agit du minimum (r\u00e9cursivement) de son sous-arbre gauche . Pour le maximum , c'est le m\u00eame principe mais avec le sous-arbre droit . Exercice 7 Compl\u00e9tez les m\u00e9thodes minimum_abr et maximum_abr qui renvoient la valeur minimale et la valeur maximale des n\u0153uds de l'arbre dans le cas d'un arbre binaire de recherche . Solution - Exercice 7 def minimum_abr ( self : 'Arbre' ) -> int : ''' Renvoie la valeur minimale des noeuds de l'arbre binaire de recherche :CU: self.est_ABR() == True and not self.est_vide() ''' if self . gauche () . est_vide (): return self . valeur_racine () else : return self . gauche () . minimum_abr () def maximum_abr ( self : 'Arbre' ) -> int : ''' Renvoie la valeur maximale des noeuds de l'arbre binaire de recherche :CU: self.est_ABR() == True and not self.est_vide() ''' if self . droite () . est_vide (): return self . valeur_racine () else : return self . droite () . maximum_abr ()","title":"Aller plus loin : minimum et maximum d'un arbre binaire de recherche"},{"location":"tri_selection/","text":"Le tri par s\u00e9lection Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme constat\u00e9 pendant l'activit\u00e9 pr\u00e9liminaire, inefficace . Pr\u00e9sentation du tri L'algorithme du tri par s\u00e9lection peut \u00eatre \u00e9crit de plusieurs mani\u00e8res diff\u00e9rentes : en it\u00e9ratif ou en r\u00e9cursif , en place ou non. Info Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. L'algorithme pr\u00e9sent\u00e9 sera \u00e9crit de mani\u00e8re it\u00e9rative et en place . On pr\u00e9sentera l'algorithme du tri par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 algorithmes : l'algorithme principal tri_selection(tableau) , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR i ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, i) \u2003\u2003\u2003\u2003 SI indice_min \u2260 i, ALORS \u2003\u2003\u2003\u2003\u2003\u2003echanger(tableau, i, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments' ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR i ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 POUR j ALLANT DE i + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[j] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 j \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003 SI indice_min \u2260 i, ALORS \u2003\u2003\u2003\u2003\u2003\u2003temp \u2190 tableau[i] \u2003\u2003\u2003\u2003\u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003tableau[j] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Notes La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . La condition SI indice_min \u2260 i, ALORS permet d'\u00e9viter d'effectuer une permutation si l'\u00e9l\u00e9ment d'indice i correspond \u00e0 l'\u00e9l\u00e9ment minimal . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple de d\u00e9roulement du tri par s\u00e9lection Animation Voici une animation du tri par s\u00e9lection permettant de mieux visualiser le d\u00e9roulement de cet algorithme. \u00c0 vous de jouer D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [5, 3, 1, 4, 6, 2] . Complexit\u00e9 du tri par s\u00e9lection ...","title":"Tri par s\u00e9lection"},{"location":"tri_selection/#le-tri-par-selection","text":"Le tri par s\u00e9lection (du minimum ou du maximum ) est un algorithme de tri par comparaisons . Il s'agit d'un algorithme simple mais qui est, comme constat\u00e9 pendant l'activit\u00e9 pr\u00e9liminaire, inefficace .","title":"Le tri par s\u00e9lection"},{"location":"tri_selection/#presentation-du-tri","text":"L'algorithme du tri par s\u00e9lection peut \u00eatre \u00e9crit de plusieurs mani\u00e8res diff\u00e9rentes : en it\u00e9ratif ou en r\u00e9cursif , en place ou non. Info Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure. L'algorithme pr\u00e9sent\u00e9 sera \u00e9crit de mani\u00e8re it\u00e9rative et en place . On pr\u00e9sentera l'algorithme du tri par s\u00e9lection du minimum . Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 algorithmes : l'algorithme principal tri_selection(tableau) , l'algorithme minimum(tableau, debut) permettant la recherche de l'indice de l' \u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice debut donn\u00e9, l'algorithme echanger(tableau, i, j) permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices i et j donn\u00e9s. Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR i ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, i) \u2003\u2003\u2003\u2003 SI indice_min \u2260 i, ALORS \u2003\u2003\u2003\u2003\u2003\u2003echanger(tableau, i, indice_min) \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Algorithme de recherche du minimum ALGORITHME : minimum ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments debut : l' indice \u00e0 partir duquel effectuer la recherche SORTIE : l' indice de l'\u00e9l\u00e9ment minimal dans l'intervalle [debut, longueur(tableau) - 1] du tableau D\u00c9BUT \u2003\u2003indice_min \u2190 debut \u2003\u2003 POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003 SI tableau[i] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003 FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME Algorithme d'\u00e9change d'\u00e9l\u00e9ments' ALGORITHME : echanger ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments i : l' indice d'un \u00e9l\u00e9ment du tableau j : l' indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place) D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Voici enfin une version en un seul algorithme : Algorithme du tri par s\u00e9lection ALGORITHME : tri_selection ENTR\u00c9ES : tableau : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s . SORTIE : aucune (tri en place ) D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) \u2003\u2003 POUR i ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 i \u2003\u2003\u2003\u2003 POUR j ALLANT DE i + 1 \u00c0 n - 1 \u2003\u2003\u2003\u2003\u2003\u2003 SI tableau[j] < tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 j \u2003\u2003\u2003\u2003 FIN POUR \u2003\u2003\u2003\u2003 SI indice_min \u2260 i, ALORS \u2003\u2003\u2003\u2003\u2003\u2003temp \u2190 tableau[i] \u2003\u2003\u2003\u2003\u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003tableau[j] \u2190 temp \u2003\u2003 FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME Notes La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 n - 2 car si tous les \u00e9l\u00e9ments de l'intervalle [0, longueur(tableau) - 2] sont tri\u00e9s , l'\u00e9l\u00e9ment d' indice longueur(tableau) - 1 est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position . La condition SI indice_min \u2260 i, ALORS permet d'\u00e9viter d'effectuer une permutation si l'\u00e9l\u00e9ment d'indice i correspond \u00e0 l'\u00e9l\u00e9ment minimal . Stabilit\u00e9 du tri Un tri est dit stable s'il pr\u00e9serve l\u2019 ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9. Exemple de d\u00e9roulement du tri par s\u00e9lection Animation Voici une animation du tri par s\u00e9lection permettant de mieux visualiser le d\u00e9roulement de cet algorithme. \u00c0 vous de jouer D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau [5, 3, 1, 4, 6, 2] .","title":"Pr\u00e9sentation du tri"},{"location":"tri_selection/#complexite-du-tri-par-selection","text":"...","title":"Complexit\u00e9 du tri par s\u00e9lection"}]}